<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aero Flight: Final Pro Fixed</title>
    <!-- ADDED: Socket.IO Client Library -->
    <script src="https://cdn.socket.io/4.7.4/socket.io.min.js"></script>
    <style>
        /* FIX 1: Prevent mobile scroll/zoom via CSS */
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; user-select: none; -webkit-user-select: none; touch-action: none; }
        #game-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
            padding: 20px; box-sizing: border-box;
        }

        .hud-top { display: flex; justify-content: space-between; align-items: flex-start; }
        
        /* LEFT HUD */
        .left-hud { display: flex; flex-direction: column; align-items: flex-start; gap: 15px; }

        /* RIGHT HUD */
        .right-hud { display: flex; flex-direction: column; align-items: flex-end; gap: 10px; pointer-events: auto; }

        .top-right-row { display: flex; align-items: flex-start; gap: 15px; }

        /* Leaderboard Style */
        .leaderboard-box {
            background: rgba(0, 0, 0, 0.6); padding: 15px; border-radius: 10px;
            color: white; min-width: 220px; pointer-events: none; backdrop-filter: blur(4px);
            border-left: 5px solid #ffd700;
        }
        .lb-title { font-weight: 900; font-size: 14px; color: #ffd700; border-bottom: 1px solid #555; padding-bottom: 5px; margin-bottom: 8px; letter-spacing: 1px; }
        .lb-row { display: flex; justify-content: space-between; font-size: 14px; margin-bottom: 4px; font-weight: bold; }
        .lb-name { color: #ddd; }
        .lb-score { color: #fff; font-family: monospace; }
        .lb-player { color: #00ff00; text-shadow: 0 0 5px #00ff00; } 
        .lb-rank-1 { color: #ffd700; } 

        .pause-btn { background: rgba(0, 0, 0, 0.6); color: white; border: 2px solid white; width: 40px; height: 40px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; cursor: pointer; transition: 0.2s; }
        .pause-btn:hover { background: white; color: black; box-shadow: 0 0 15px white; }

        .bar-container { width: 220px; text-align: left; pointer-events: none; }
        .right-hud .bar-container { text-align: right; }
        .bar-label { font-weight: 900; font-size: 14px; margin-bottom: 3px; letter-spacing: 1px; text-shadow: 0 0 5px black; }
        .bar-bg { width: 100%; height: 12px; background: rgba(0,0,0,0.6); border: 1px solid #444; border-radius: 6px; overflow: hidden; transform: skewX(-20deg); box-shadow: 0 0 5px rgba(0,0,0,0.5); }
        .health-label { color: #00ff00; text-shadow: 0 0 10px #00ff00; }
        #health-fill { width: 100%; height: 100%; background: linear-gradient(90deg, #cc0000, #00ff00); box-shadow: 0 0 10px #00ff00; transition: width 0.1s linear; }
        .boost-label { color: #00d2ff; text-shadow: 0 0 10px #00d2ff; }
        #boost-fill { width: 100%; height: 100%; background: linear-gradient(90deg, #0066ff, #00d2ff); box-shadow: 0 0 15px #00d2ff; transition: width 0.1s linear; }

        /* FPS COUNTER */
        #fps-counter {
            background: rgba(0,0,0,0.5); color: #00ff00; padding: 5px 10px; 
            border-radius: 5px; font-family: monospace; font-weight: bold;
            font-size: 12px; pointer-events: none; margin-bottom: 5px;
        }

        /* MINIMAP */
        #minimap-container {
            position: absolute; bottom: 20px; left: 20px;
            width: 140px; height: 140px;
            background: rgba(0, 10, 30, 0.8);
            border: 2px solid #00d2ff;
            border-radius: 50%;
            overflow: hidden;
            pointer-events: none;
            box-shadow: 0 0 15px rgba(0, 210, 255, 0.3);
        }
        #minimap-canvas { width: 100%; height: 100%; }

        /* PRO GLASS UI STYLES */
        .screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.5); 
            backdrop-filter: blur(8px);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            pointer-events: auto; z-index: 10;
        }
        .hidden { display: none !important; }

        .menu-box {
            background: rgba(12, 20, 30, 0.85); 
            border: 2px solid #00d2ff;
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            box-shadow: 0 0 50px rgba(0, 210, 255, 0.25), inset 0 0 30px rgba(0, 210, 255, 0.1);
            width: 550px;
            max-width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            animation: glowPulse 4s infinite alternate;
        }

        @keyframes glowPulse {
            from { box-shadow: 0 0 30px rgba(0, 210, 255, 0.2); }
            to { box-shadow: 0 0 60px rgba(0, 210, 255, 0.4); }
        }
        
        h1 { font-size: 56px; color: #fff; text-transform: uppercase; margin: 0 0 10px 0; font-weight: 900; letter-spacing: 4px; text-shadow: 0 0 20px #00d2ff; font-style: italic; }
        h2 { color: #00d2ff; font-weight: 300; margin-bottom: 30px; letter-spacing: 4px; font-size: 18px; text-transform: uppercase; }
        
        .action-btn {
            display: block; width: 100%; padding: 18px 0; margin: 15px 0;
            background: linear-gradient(135deg, #00d2ff, #0077ff); 
            border: none; color: #fff; border-radius: 50px;
            font-size: 20px; font-weight: 900; cursor: pointer;
            text-transform: uppercase; letter-spacing: 2px;
            box-shadow: 0 5px 20px rgba(0, 210, 255, 0.4);
            transition: all 0.2s cubic-bezier(0.25, 0.8, 0.25, 1);
            position: relative; overflow: hidden;
        }
        .action-btn:hover { transform: translateY(-2px) scale(1.02); box-shadow: 0 10px 40px rgba(0, 210, 255, 0.6); filter: brightness(1.2); }
        .action-btn:active { transform: translateY(1px); }
        .action-btn:disabled { background: #555; cursor: not-allowed; transform: none; box-shadow: none; }
        
        .secondary-btn { background: rgba(255,255,255,0.05); border: 1px solid #555; box-shadow: none; font-size: 16px; }
        .secondary-btn:hover { background: rgba(255,255,255,0.15); border-color: #fff; }

        .win-text { color: #00ff00; font-size: 60px; text-shadow: 0 0 30px #00ff00; font-weight: 900; }
        .lose-text { color: #ff4444; font-size: 60px; text-shadow: 0 0 30px #ff4444; font-weight: 900; }

        .settings-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 20px; text-align: left; }
        .setting-row { display: flex; justify-content: space-between; align-items: center; background: rgba(0,0,0,0.3); padding: 10px 20px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.05); }
        .setting-label { color: #aaa; font-size: 14px; font-weight: bold; letter-spacing: 1px; }
        .key-bind-btn { background: #222; border: 1px solid #555; color: #fff; padding: 5px 12px; border-radius: 4px; cursor: pointer; font-family: monospace; font-weight: bold; min-width: 70px; text-align: center; transition: all 0.2s; }
        .key-bind-btn:hover { background: #444; border-color: #00d2ff; color: #00d2ff; }
        .key-bind-btn.listening { background: #d35400; border-color: #e67e22; animation: pulse 0.5s infinite; }
        
        .toggle-active { background: rgba(0, 255, 0, 0.2); border-color: #00ff00; color: #00ff00; }
        .toggle-inactive { background: rgba(255, 0, 0, 0.2); border-color: #ff0000; color: #ff0000; }

        /* MOBILE CONTROLS */
        .mobile-controls {
            display: none; /* Hidden on desktop by default */
            position: absolute; bottom: 20px; width: 100%; 
            padding: 0 20px; box-sizing: border-box;
            justify-content: space-between; pointer-events: none;
            z-index: 100;
        }
        @media (max-width: 1024px) { .mobile-controls { display: flex; } }

        .control-group { pointer-events: auto; display: flex; gap: 10px; }
        .dpad { display: grid; grid-template-columns: 60px 60px 60px; grid-template-rows: 60px 60px; gap: 5px; }
        .mob-btn {
            width: 60px; height: 60px; background: rgba(255,255,255,0.1);
            border: 2px solid rgba(255,255,255,0.3); border-radius: 50%;
            color: white; font-weight: bold; font-size: 20px;
            display: flex; align-items: center; justify-content: center;
            user-select: none; -webkit-user-select: none;
            backdrop-filter: blur(4px);
        }
        .mob-btn:active { background: rgba(0, 210, 255, 0.4); border-color: #00d2ff; transform: scale(0.95); }
        .mob-btn-rect { width: 80px; height: 60px; border-radius: 15px; font-size: 14px; }
        .mob-fire { border-color: #ff4444; } .mob-fire:active { background: rgba(255, 0, 0, 0.3); }
        .mob-boost { border-color: #00d2ff; }
        
        /* Grid positioning for D-PAD */
        .btn-up { grid-column: 2; grid-row: 1; }
        .btn-left { grid-column: 1; grid-row: 2; }
        .btn-down { grid-column: 2; grid-row: 2; }
        .btn-right { grid-column: 3; grid-row: 2; }

        /* LOADING OVERLAY */
        #loading-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); backdrop-filter: blur(5px);
            display: flex; justify-content: center; align-items: center;
            flex-direction: column; z-index: 1000;
        }
        .spinner {
            width: 50px; height: 50px; border: 5px solid rgba(255,255,255,0.1);
            border-top: 5px solid #00d2ff; border-radius: 50%;
            animation: spin 1s linear infinite; margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="game-container"></div>

    <div id="ui-layer">
        <div class="hud-top">
            <div class="left-hud">
                <div id="fps-counter">FPS: 0</div>
                <div class="bar-container">
                    <div class="bar-label health-label">HEALTH</div>
                    <div class="bar-bg">
                        <div id="health-fill"></div>
                    </div>
                </div>
                <div class="leaderboard-box">
                    <div class="lb-title">RACE RANKING</div>
                    <div id="leaderboard-list"></div>
                </div>
            </div>
            
            <div class="right-hud">
                <div class="top-right-row">
                    <div class="bar-container">
                        <div class="bar-label boost-label">BOOST</div>
                        <div class="bar-bg">
                            <div id="boost-fill"></div>
                        </div>
                    </div>
                    <div class="pause-btn" onclick="togglePause()">||</div>
                </div>
            </div>
        </div>

        <!-- MINIMAP -->
        <div id="minimap-container">
            <canvas id="minimap-canvas" width="140" height="140"></canvas>
        </div>

        <!-- MOBILE CONTROLS -->
        <div class="mobile-controls">
            <div class="control-group dpad">
                <div class="mob-btn btn-up" ontouchstart="setKey('up', true)" ontouchend="setKey('up', false)">â–²</div>
                <div class="mob-btn btn-left" ontouchstart="setKey('left', true)" ontouchend="setKey('left', false)">â—€</div>
                <div class="mob-btn btn-down" ontouchstart="setKey('down', true)" ontouchend="setKey('down', false)">â–¼</div>
                <div class="mob-btn btn-right" ontouchstart="setKey('right', true)" ontouchend="setKey('right', false)">â–¶</div>
            </div>
            <div class="control-group" style="flex-direction: column; justify-content: flex-end;">
                <div class="mob-btn mob-btn-rect mob-fire" ontouchstart="setKey('fire', true)" ontouchend="setKey('fire', false)">FIRE</div>
                <div class="mob-btn mob-btn-rect mob-boost" ontouchstart="setKey('boost', true)" ontouchend="setKey('boost', false)">BOOST</div>
            </div>
        </div>
    </div>

    <!-- LOADING OVERLAY -->
    <div id="loading-overlay" class="hidden">
        <div class="spinner"></div>
        <h2 style="color:#fff;">CONNECTING...</h2>
    </div>

    <!-- MAIN MENU -->
    <div id="start-screen" class="screen">
        <div class="menu-box">
            <h1>SKY PILOT</h1>
            <!-- Single player-->
            <button class="action-btn" onclick="startSinglePlayer()">LAUNCH MISSION</button>
            <!-- Multiplayer -->
            <button class="action-btn secondary-btn" onclick="openMpMenu()">MULTIPLAYER</button>
            <!-- Settings-->
            <button class="action-btn secondary-btn" onclick="showSettings()">SETTINGS / CONTROLS</button>
        </div>
    </div>
    
    <!-- MULTIPLAYER MENU -->
    <div id="mp-menu-screen" class="screen hidden">
      <div class="menu-box">
        <h1>MULTIPLAYER</h1>

        <button id="btn-create" class="action-btn" onclick="mpCreateRoom()">CREATE ROOM</button>

        <div style="margin-top:15px;"></div>

        <input id="mp-room-code" placeholder="Enter Room Code (e.g. ABCD)" style="margin-top:10px; padding: 12px; width: 80%; border-radius: 5px; border: none; background: rgba(255,255,255,0.1); color: #fff; font-size: 16px; font-weight: bold; text-align: center; text-transform: uppercase;">
        <button id="btn-join" class="action-btn secondary-btn" onclick="mpJoinRoom()">JOIN ROOM</button>

        <button class="action-btn secondary-btn" onclick="showStartMenu()">BACK</button>
      </div>
    </div>

    <!-- LOBBY SCREEN -->
    <div id="lobby-screen" class="screen hidden">
      <div class="menu-box">
        <h1>LOBBY</h1>

        <div style="color:#00d2ff; font-weight:800; margin:10px 0;">
          ROOM: <span id="lobby-room-id">----</span>
        </div>

        <div style="text-align:left; margin-top:10px;">
          <div style="color:#fff; font-weight:900; margin-bottom:8px;">PLAYERS</div>
          <div id="lobby-player-list" style="color:#ddd; font-family:monospace;"></div>
        </div>

        <button id="host-start-btn" class="action-btn hidden" onclick="mpHostStartGame()">START GAME</button>
        <button class="action-btn secondary-btn" onclick="mpLeaveLobby()">LEAVE</button>
      </div>
    </div>

    <!-- COUNTDOWN -->
    <div id="countdown-screen" class="screen hidden">
      <div class="menu-box">
        <h1 id="countdown-text" style="font-size:90px;">3</h1>
        <p style="color:#00d2ff; font-weight:800;">GET READY</p>
      </div>
    </div>

    <!-- SETTINGS -->
    <div id="settings-screen" class="screen hidden">
        <div class="menu-box">
            <h2>SYSTEM OPTIONS</h2>
            <div class="settings-grid">
                <div class="setting-row"><span>SFX</span><button id="set-snd-btn" class="key-bind-btn" onclick="toggleSoundSettings()">ON</button></div>
                <div class="setting-row"><span>MUSIC</span><button id="set-mus-btn" class="key-bind-btn" onclick="toggleMusicSettings()">ON</button></div>
            </div>
            <h2>CONTROLS</h2>
            <div class="settings-grid" id="controls-list"></div>
            <button class="action-btn secondary-btn" onclick="hideSettings()">BACK</button>
        </div>
    </div>

    <!-- PAUSE -->
    <div id="pause-screen" class="screen hidden">
        <div class="menu-box">
            <h1>PAUSED</h1>
            <button class="action-btn" onclick="togglePause()">RESUME FLIGHT</button>
            <button class="action-btn secondary-btn" onclick="showSettings()">SETTINGS</button>
            <button class="action-btn secondary-btn" style="border-color: #ff4444; color: #ff4444;" onclick="location.reload()">ABORT MISSION</button>
        </div>
    </div>

    <!-- END SCREEN -->
    <div id="end-screen" class="screen hidden">
        <div class="menu-box">
            <h1 id="end-title" class="win-text">VICTORY</h1>
            <p id="end-msg" style="color: #fff; font-size: 20px;">Rank 1 Secured.</p>
            <button class="action-btn" onclick="location.reload()">RE-ENGAGE</button>
        </div>
    </div>

    <script>
        // FIX 1: Prevent default touch actions like scroll/zoom
        document.body.addEventListener("touchmove", e => e.preventDefault(), { passive: false });

        // =============================
        // MULTIPLAYER LOBBY SYSTEM
        // =============================
        let gameMode = "single"; // "single" | "multi"
        let mp = {
          roomId: null,
          isHost: false,
          inLobby: false,
          playerName: null,
          action: null // 'create' or 'join'
        };
        const otherPlayers = {}; // Store other players' info { id, name, mesh, x,y,z }
        let lobbyTimer = null; // Timer for lobby expiry
        
        // ============================================
        // âœ… FIX: SOCKET INITIALIZATION & DEBUG LOGS
        // ============================================
        let socket;
        if (typeof io !== 'undefined') {
            // FIX 1: URL TYPO FIXED (aero instead of aera)
            socket = io("https://aero-flight.onrender.com");
            
            // FIX: Any event debugger
            socket.onAny((event, ...args) => {
              console.log("ðŸ“© SOCKET EVENT:", event, args);
            });

            // DEBUG: Connection check
            socket.on('connect', () => {
                console.log("âœ… Socket Connected! ID:", socket.id);
            });
            
            socket.on('connect_error', (err) => {
                console.error("âŒ Socket Connection Error:", err.message);
            });
        } else {
            console.warn("Socket.io not found. Multiplayer features will not work.");
            socket = { emit: () => {}, on: () => {}, connected: false }; // Mock object
        }

        // show/hide helpers
        // âœ… FIX: Robust showScreen function
        function showScreen(id) {
          document.querySelectorAll(".screen").forEach(s => s.classList.add("hidden"));
          const el = document.getElementById(id);
          if (el) el.classList.remove("hidden");
          else console.error("Screen not found:", id);
        }

        function showLoading(show) {
            const el = document.getElementById("loading-overlay");
            if(show) el.classList.remove("hidden");
            else el.classList.add("hidden");
        }

        function showStartMenu() { showScreen("start-screen"); }
        function openMpMenu() { showScreen("mp-menu-screen"); }

        // SINGLE PLAYER START (existing)
        function startSinglePlayer() {
          gameMode = "single";
          initGame(); 
        }

        // 5-Minute Timer Logic
        function startLobbyTimer() {
            if(lobbyTimer) clearTimeout(lobbyTimer);
            lobbyTimer = setTimeout(() => {
                // FIX 3: Timer should only work for host
                if(mp.inLobby && mp.isHost && !isPlaying) {
                    alert("Lobby timeout (5 mins). Closing room.");
                    mpLeaveLobby();
                }
            }, 5 * 60 * 1000); // 5 Minutes
        }

        // âœ… FIX: CREATE ROOM
        function mpCreateRoom() {
          gameMode = "multi";
          mp.action = "create";

          // FIX: Check if socket is actually connected before sending
          if (!socket || !socket.connected) {
            alert("Server se connect nahi hua. 2 sec wait karke dobara try karo. (Check Console for errors)");
            return;
          }

          mp.playerName = prompt("Enter your name:", "PLAYER") || "PLAYER";
          showLoading(true); // Show loading
          
          // GENERATE RANDOM CODE
          mp.roomId = Math.random().toString(36).substring(2, 6).toUpperCase();
          console.log("Creating/Joining room:", mp.roomId);
          alert("Room Created! Share Code: " + mp.roomId);
          
          // FIX (Bug 1): Sending object { room, name }
          socket.emit("joinRoom", { room: mp.roomId, name: mp.playerName });
          
          // Use timeout to simulate server response for creation, 
          // as we assume we are the first one.
          setTimeout(() => {
              showLoading(false);
              mp.isHost = true; 
              mp.inLobby = true;
              document.getElementById("lobby-room-id").innerText = mp.roomId;
              showScreen("lobby-screen");
              document.getElementById("host-start-btn").classList.remove("hidden");
              refreshLobbyUI();
              startLobbyTimer();
          }, 500);
        }

        // âœ… FIX: JOIN ROOM WITH VALIDATION
        function mpJoinRoom() {
          gameMode = "multi";
          mp.action = "join";
          
           // FIX: Connection check for join too
          if (!socket || !socket.connected) {
             alert("Server se connect nahi hua. Please wait.");
             return;
          }

          mp.playerName = prompt("Enter your name:", "PLAYER") || "PLAYER";

          const rawCode = document.getElementById("mp-room-code").value;
          const room = rawCode.trim().toUpperCase(); // FORCE UPPERCASE
          
          if (!room) { alert("Enter Room Code"); return; }

          mp.roomId = room;
          showLoading(true);

          // FIX (Bug 1): Sending object { room, name }
          socket.emit("joinRoom", { room: room, name: mp.playerName });
          
          // Timeout Safety: If server logic fails or empty
          setTimeout(() => {
              if(!mp.inLobby) {
                  showLoading(false);
                  alert("Connection Timed Out. Server didn't respond or Room doesn't exist.");
                  mpLeaveLobby();
              }
          }, 8000);
        }

        function mpLeaveLobby() {
          if(lobbyTimer) clearTimeout(lobbyTimer);
          if (!mp.roomId) return showStartMenu();
          
          // Cleanup other players
          Object.values(otherPlayers).forEach(p => {
             if (scene && p.mesh) scene.remove(p.mesh);
             // disposeHierarchy not needed for small objects usually but good practice
             if(p.mesh) disposeHierarchy(p.mesh);
          });
          for (let k in otherPlayers) delete otherPlayers[k];

          // FIX 4: Check connection before emit
          if (socket && socket.connected) {
              socket.emit("leaveRoom", { room: mp.roomId });
          }
          
          mp.roomId = null;
          mp.isHost = false;
          mp.inLobby = false;
          mp.action = null;
          showStartMenu();
        }

        // Host start game
        function mpHostStartGame() {
          if (!mp.isHost) { alert("Only host can start."); return; }
          if(lobbyTimer) clearTimeout(lobbyTimer);
          // FIX: Emit 'startGame' with both room and roomId for safety
          socket.emit("startGame", { room: mp.roomId, roomId: mp.roomId }); 
        }

        // Lobby UI update
        function refreshLobbyUI() {
            const list = document.getElementById("lobby-player-list");
            list.innerHTML = "";

            // Add self
            const selfRow = document.createElement("div");
            selfRow.textContent = `1. ${mp.playerName} ${mp.isHost ? "(HOST)" : "(YOU)"}`;
            selfRow.style.color = "#00ff00";
            list.appendChild(selfRow);

            // Add others
            let i = 2;
            Object.keys(otherPlayers).forEach(id => {
                const p = otherPlayers[id];
                const row = document.createElement("div");
                // FIX 5: Show names if available
                row.textContent = `${i}. ${p.name || "RIVAL PILOT"}`; 
                row.style.color = "#ddd";
                list.appendChild(row);
                i++;
            });
        }
        
        function mpCountdownThenStart() {
          let n = 3;
          const txt = document.getElementById("countdown-text");

          txt.innerText = n;

          const timer = setInterval(() => {
            n--;
            if (n > 0) {
              txt.innerText = n;
            } else if (n === 0) {
              txt.innerText = "GO!";
            } else {
              clearInterval(timer);

              // âœ… Start multiplayer game (new init)
              initMultiplayerGame();
            }
          }, 1000);
        }

        function initMultiplayerGame() {
          // Multiplayer game init = tumhara same initGame logic BUT:
          // 1) enemies optional OFF
          // 2) socket movement sync ON
          // 3) gameMode = "multi"

          gameMode = "multi";

          // âœ… re-use your current init logic
          // easiest: call initGame() and then enable network sync flags
          initGame(); // builds scene, rings, plane etc.

          // IMPORTANT: Explicitly hide all screens to avoid overlays sticking
          document.getElementById("start-screen").classList.add("hidden");
          document.getElementById("lobby-screen").classList.add("hidden");
          document.getElementById("countdown-screen").classList.add("hidden");
          document.getElementById("mp-menu-screen").classList.add("hidden");
          document.getElementById("settings-screen").classList.add("hidden");
          document.getElementById("pause-screen").classList.add("hidden");
          document.getElementById("end-screen").classList.add("hidden");
          showLoading(false);
        }

        // =============================
        // MULTIPLAYER SOCKET EVENTS
        // =============================
        
        socket.on("mp_error", (msg) => {
          alert(msg || "Multiplayer error");
          showLoading(false);
        });

        // FIX 3: Room validation listeners
        socket.on("roomNotFound", () => {
            if (mp.action === 'join') {
                showLoading(false);
                alert("Invalid Room Code! Room does not exist or has expired.");
                mpLeaveLobby();
            }
        });

        // Listen for 'startGame' or 'gameStarted' (safest approach)
        const handleGameStart = () => {
            showScreen("countdown-screen");
            mpCountdownThenStart();
        };
        
        socket.on("startGame", handleGameStart);
        socket.on("gameStarted", handleGameStart); // âœ… Added 'gameStarted'
        socket.on("mp_game_starting", handleGameStart);
        
        // --- MULTIPLAYER ENTITY SYNC (UPDATED) ---
        
        // FIX 3: Handling currentPlayers to start game and map ID correctly
        socket.on('currentPlayers', (players) => {
            
            const playerIds = Object.keys(players);
            
            // âœ… VALIDATION LOGIC: Check if room exists
            if (mp.action === 'join' && !mp.inLobby) {
                // FIX 2: Removed aggressive check (<=1) to prevent false reject
                // Just enter lobby
                mp.inLobby = true;
                mp.isHost = false;
                showLoading(false);
                document.getElementById("lobby-room-id").innerText = mp.roomId;
                showScreen("lobby-screen");
                document.getElementById("host-start-btn").classList.add("hidden");
            }

            // FIX: Remove stale players (ghosts)
            Object.keys(otherPlayers).forEach(existingId => {
                if (!players[existingId]) {
                    removeOtherPlayer(existingId);
                }
            });

            playerIds.forEach((id) => {
                // FIX 3: Use key 'id' instead of property .playerId
                if (id === socket.id) return;
                
                // Add player with ID mapped correctly for addOtherPlayer
                const pData = players[id];
                addOtherPlayer({ playerId: id, ...pData });
            });

            // FIX: Refresh UI whenever player list changes
            if (mp.inLobby) refreshLobbyUI();
        });

        // FIX 4: Handling newPlayer data mismatch
        socket.on('newPlayer', (data) => {
            // Server sends { id: socket.id, player: {...} }
            // We adapt it to flattened object with playerId
            addOtherPlayer({ playerId: data.id, ...data.player });
            
            // FIX: Refresh UI on new player
            if (mp.inLobby) refreshLobbyUI();
        });

        socket.on('playerDisconnected', (playerId) => {
            removeOtherPlayer(playerId);
            // FIX: Refresh UI on disconnect
            if (mp.inLobby) refreshLobbyUI();
        });

        // FIX 5: Handling playerMoved data mismatch
        socket.on('playerMoved', (playerInfo) => {
            // Server sends object with .id property
            const pEntry = otherPlayers[playerInfo.id];
            if (pEntry && pEntry.mesh) {
                const mesh = pEntry.mesh;
                mesh.position.set(playerInfo.x, playerInfo.y, playerInfo.z);
                
                // Fix: Sync using Quaternion for smoothness
                if (playerInfo.quaternion) {
                    mesh.quaternion.set(playerInfo.quaternion.x, playerInfo.quaternion.y, playerInfo.quaternion.z, playerInfo.quaternion.w);
                } else {
                    // Fallback to Euler if server sends old format
                    mesh.rotation.set(playerInfo.rotation.x, playerInfo.rotation.y, playerInfo.rotation.z);
                }
            }
        });

        function addOtherPlayer(playerInfo) {
            // FIX 5 & 8: Store data even if scene missing (Lobby phase)
            let pEntry = otherPlayers[playerInfo.playerId];
            if (!pEntry) {
                pEntry = { 
                    playerId: playerInfo.playerId, 
                    name: playerInfo.name, 
                    mesh: null, 
                    x: playerInfo.x || 0, 
                    y: playerInfo.y || 0, 
                    z: playerInfo.z || 0 
                };
                otherPlayers[playerInfo.playerId] = pEntry;
            } else {
                // Update name if changed
                if(playerInfo.name) pEntry.name = playerInfo.name;
            }

            // Create mesh if scene exists and mesh doesn't
            // FIX 4: Strict guard to prevent duplication
            if (scene && !pEntry.mesh) {
                const mesh = createPlaneMesh(0x00ff00); // Green for allies
                mesh.position.set(pEntry.x, pEntry.y, pEntry.z);
                scene.add(mesh);
                pEntry.mesh = mesh;
            }
        }

        function removeOtherPlayer(playerId) {
            const pEntry = otherPlayers[playerId];
            if (pEntry) {
                if(pEntry.mesh && scene) {
                    scene.remove(pEntry.mesh);
                    disposeHierarchy(pEntry.mesh);
                }
                delete otherPlayers[playerId];
            }
        }


        // --- CONFIG & STATE ---
        const TERRAIN_COLORS = { WATER: 0x1E90FF, SAND: 0xEEDD82, GRASS: 0x556B2F, ROCK: 0x808080, SNOW: 0xFFFFFF };
        const NORMAL_SPEED = 6.5; 
        const BOOST_SPEED = 14.5; 
        const TURN_SPEED = 0.05; 
        const LIFT_SPEED = 3.5;  
        
        const RINGS_PER_LAP = 4;
        const TOTAL_LAPS = 2;
        const TOTAL_RINGS_WIN = RINGS_PER_LAP * TOTAL_LAPS; 

        let bindings = { up: 'w', down: 's', left: 'a', right: 'd', boost: ' ', fire: 'shift' };
        const keyDisplayNames = { ' ': 'SPACE', 'arrowup': 'UP', 'arrowdown': 'DOWN', 'arrowleft': 'LEFT', 'arrowright': 'RIGHT', 'control': 'CTRL' };

        let scene, camera, renderer;
        let planeRig, planeMesh, guideArrow; 
        let enemies = [];
        let repairKits = []; 
        let rings = []; 
        let ringWaypoints = [];
        let currentRingObj = null; 
        // Ring lock is now attached to individual ring objects via userData

        let bullets = []; 
        let isPlaying = false;
        let isPaused = false;
        let isRebinding = false; // Fix: Flag for key rebinding
        let lastNetSend = 0; // Fix: For throttling MP events
        
        let boostLevel = 100;
        const BOOST_DRAIN = 0.8;
        const BOOST_REFILL = 0.3;
        let health = 100;
        const COLLISION_DAMAGE = 0.6; 
        let lastFireTime = 0;
        const FIRE_RATE = 100; 

        let playerStats = { name: "PLAYER", rings: 0, progress: 0 };
        let enemyStats = [
            { name: "ACE", rings: 0, obj: null },
            { name: "VIPER", rings: 0, obj: null },
            { name: "GHOST", rings: 0, obj: null },
            { name: "HAWK", rings: 0, obj: null }
        ];
        let enemiesAliveCount = 4;

        const activeKeys = {}; 
        let visualRoll = 0;
        let visualPitch = 0;

        let audioCtx;
        let boostOsc, boostGain, boostNoise, boostNoiseGain;
        let noiseNode, noiseGain;
        let isMusicOn = true;
        let isSoundOn = true;

        // FPS Variables
        let lastFrameTime = performance.now();
        let frameCount = 0;
        const fpsElem = document.getElementById('fps-counter');

        // Minimap Variables
        const minimapCanvas = document.getElementById('minimap-canvas');
        const minimapCtx = minimapCanvas.getContext('2d');

        // --- AUDIO SYSTEM ---
        const AudioSys = {
            init: function() {
                if (audioCtx) return;
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                const scrapeBuffer = audioCtx.createBuffer(1, audioCtx.sampleRate, audioCtx.sampleRate);
                const sData = scrapeBuffer.getChannelData(0);
                for(let i=0; i<sData.length; i++) sData[i] = Math.random() * 2 - 1;
                noiseNode = audioCtx.createBufferSource();
                noiseNode.buffer = scrapeBuffer;
                noiseNode.loop = true;
                noiseGain = audioCtx.createGain();
                noiseGain.gain.value = 0;
                noiseNode.connect(noiseGain);
                noiseGain.connect(audioCtx.destination);
                noiseNode.start();

                boostOsc = audioCtx.createOscillator();
                boostOsc.type = 'triangle';
                boostOsc.frequency.value = 200;
                boostGain = audioCtx.createGain();
                boostGain.gain.value = 0;
                boostOsc.connect(boostGain);
                boostGain.connect(audioCtx.destination);
                boostOsc.start();

                boostNoise = audioCtx.createBufferSource();
                boostNoise.buffer = scrapeBuffer;
                boostNoise.loop = true;
                const f = audioCtx.createBiquadFilter();
                f.type = 'bandpass'; f.frequency.value = 1000;
                boostNoiseGain = audioCtx.createGain();
                boostNoiseGain.gain.value = 0;
                boostNoise.connect(f);
                f.connect(boostNoiseGain);
                boostNoiseGain.connect(audioCtx.destination);
                boostNoise.start();

                this.startNewMusic();
            },
            updateContinuousAudio: function(isBoosting, isDamaging) {
                if(!audioCtx || !isSoundOn) {
                    if(audioCtx) {
                        boostGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.1);
                        boostNoiseGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.1);
                        noiseGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.1);
                    }
                    return;
                }
                const now = audioCtx.currentTime;
                if (isBoosting) {
                    boostOsc.frequency.setTargetAtTime(600, now, 0.5); 
                    boostGain.gain.setTargetAtTime(0.15, now, 0.1);
                    boostNoiseGain.gain.setTargetAtTime(0.3, now, 0.1);
                } else {
                    boostOsc.frequency.setTargetAtTime(200, now, 0.5);
                    boostGain.gain.setTargetAtTime(0, now, 0.2);
                    boostNoiseGain.gain.setTargetAtTime(0, now, 0.2);
                }
                const targetVol = isDamaging ? 0.4 : 0;
                noiseGain.gain.setTargetAtTime(targetVol, now, 0.1);
            },
            playGun: function() {
                if(!audioCtx || !isSoundOn) return;
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'square'; 
                osc.frequency.setValueAtTime(800, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.15);
                gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.2);
            },
            playExplosion: function() {
                if(!audioCtx || !isSoundOn) return;
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
                gain.gain.setValueAtTime(0.5, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.5);
            },
            playRepair: function() {
                if(!audioCtx || !isSoundOn) return;
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(400, audioCtx.currentTime);
                osc.frequency.linearRampToValueAtTime(800, audioCtx.currentTime + 0.2);
                gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.3);
            },
            playRing: function() {
                if(!audioCtx || !isSoundOn) return;
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(1200, audioCtx.currentTime);
                osc.frequency.linearRampToValueAtTime(1800, audioCtx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.5);
            },
            startNewMusic: function() {
                if (this.isPlayingMusic) return;
                this.isPlayingMusic = true;
                const bassNotes = [87.31, 87.31, 87.31, 87.31, 98.00, 98.00, 110.00, 130.81]; 
                let noteIdx = 0;
                let nextNoteTime = audioCtx.currentTime;

                const schedule = () => {
                    if (!this.isPlayingMusic || !audioCtx) return;
                    
                    if (nextNoteTime < audioCtx.currentTime - 0.2) nextNoteTime = audioCtx.currentTime;

                    while (nextNoteTime < audioCtx.currentTime + 0.1) {
                        if (isMusicOn) {
                            const osc = audioCtx.createOscillator();
                            const gain = audioCtx.createGain();
                            osc.type = 'sawtooth';
                            const filter = audioCtx.createBiquadFilter();
                            filter.type = 'lowpass';
                            filter.frequency.value = 600;
                            osc.frequency.value = bassNotes[noteIdx % bassNotes.length];
                            
                            gain.gain.setValueAtTime(0.12, nextNoteTime);
                            gain.gain.exponentialRampToValueAtTime(0.01, nextNoteTime + 0.2);
                            
                            osc.connect(filter);
                            filter.connect(gain);
                            gain.connect(audioCtx.destination);
                            
                            osc.start(nextNoteTime);
                            osc.stop(nextNoteTime + 0.25);
                        }
                        nextNoteTime += 0.2;
                        noteIdx++;
                    }
                    setTimeout(schedule, 50); 
                };
                schedule();
            },
            toggleSound: function() { isSoundOn = !isSoundOn; this.updateContinuousAudio(false, false); return isSoundOn; },
            toggleMusic: function() { 
                // Allow toggle even if audioCtx is null
                isMusicOn = !isMusicOn; 
                if(audioCtx && isMusicOn) this.startNewMusic(); 
                if(!isMusicOn) this.isPlayingMusic = false; 
                return isMusicOn; 
            },
            stopAll: function() { 
                this.isPlayingMusic = false; 
                try { if(noiseNode) noiseNode.stop(); } catch(e){}
                try { if(boostOsc) boostOsc.stop(); } catch(e){}
                try { if(boostNoise) boostNoise.stop(); } catch(e){}
                if(audioCtx) audioCtx.close(); 
                audioCtx = null; 
            }
        };

        // --- GLOBAL LOGIC ---
        function ringCollected(collectorName) {
            AudioSys.playRing();
            let winner = null;
            if (collectorName === "PLAYER") {
                playerStats.rings++;
                playerStats.progress++;
                updateRingVisuals(); 
                if (playerStats.rings >= TOTAL_RINGS_WIN) winner = { win: true, name: "PLAYER" }; 
            } else {
                const eStat = enemyStats.find(e => e.name === collectorName);
                if(eStat) {
                    eStat.rings++;
                    // Fix: We don't double count, just update stats
                    if(eStat.rings >= TOTAL_RINGS_WIN) winner = { win: false, name: eStat.name };
                }
            }
            updateLeaderboard();
            
            if (winner) {
                if (winner.win) endGame(true, "Race Champion!");
                else endGame(false, `${winner.name} Won the Race!`);
            }
        }

        // --- UI ---
        function updateLeaderboard() {
            const list = document.getElementById('leaderboard-list');
            if(!list) return;
            list.innerHTML = '';
            
            let racers;
            if (gameMode === "multi") {
                racers = [playerStats]; // Only show self in MP until score sync is added
            } else {
                racers = [playerStats, ...enemyStats];
                // Fix: Filter dead enemies from leaderboard
                racers = racers.filter(r => r.name === "PLAYER" || (r.obj && r.obj.userData.alive));
            }
            
            racers.sort((a, b) => b.rings - a.rings);
            racers.forEach((r, i) => {
                const row = document.createElement('div');
                row.className = 'lb-row';
                const n = document.createElement('span');
                n.className = 'lb-name';
                if(r.name === 'PLAYER') n.classList.add('lb-player');
                if(i === 0) n.classList.add('lb-rank-1');
                n.innerText = `${i+1}. ${r.name}`;
                const s = document.createElement('span');
                s.className = 'lb-score';
                s.innerText = `${r.rings}/${TOTAL_RINGS_WIN}`;
                row.appendChild(n); row.appendChild(s);
                list.appendChild(row);
            });
        }
        function updateSettingsUI() {
            const list = document.getElementById('controls-list');
            if(!list) return;
            list.innerHTML = '';
            const actions = [{ id: 'up', label: 'PITCH UP' }, { id: 'down', label: 'PITCH DOWN' }, { id: 'left', label: 'TURN LEFT' }, { id: 'right', label: 'TURN RIGHT' }, { id: 'boost', label: 'BOOST' }, { id: 'fire', label: 'FIRE' }];
            actions.forEach(action => {
                const row = document.createElement('div'); row.className = 'setting-row';
                const label = document.createElement('span'); label.className = 'setting-label'; label.innerText = action.label;
                const btn = document.createElement('button'); btn.className = 'key-bind-btn';
                let keyName = bindings[action.id].toLowerCase(); if (keyDisplayNames[keyName]) keyName = keyDisplayNames[keyName];
                btn.innerText = keyName.toUpperCase(); btn.onclick = () => startRebind(action.id, btn);
                row.appendChild(label); row.appendChild(btn); list.appendChild(row);
            });
        }
        function startRebind(actionId, btnElement) {
            isRebinding = true; // Fix: Set rebind flag
            btnElement.innerText = '...'; btnElement.classList.add('listening');
            const handler = (e) => { 
                e.preventDefault(); 
                e.stopPropagation(); 
                let newKey = e.key.toLowerCase(); 
                if(newKey === ' ') newKey = ' '; 
                bindings[actionId] = newKey; 
                window.removeEventListener('keydown', handler); 
                btnElement.classList.remove('listening'); 
                isRebinding = false; // Fix: Clear rebind flag
                updateSettingsUI(); 
            };
            window.addEventListener('keydown', handler, { once: true });
        }
        function showSettings() { document.getElementById('start-screen').classList.add('hidden'); document.getElementById('pause-screen').classList.add('hidden'); document.getElementById('settings-screen').classList.remove('hidden'); updateAudioBtns(); updateSettingsUI(); }
        function updateAudioBtns() {
            const sndBtn = document.getElementById('set-snd-btn'); const musBtn = document.getElementById('set-mus-btn');
            sndBtn.innerText = isSoundOn ? "ON" : "OFF"; sndBtn.className = "key-bind-btn " + (isSoundOn ? "toggle-active" : "toggle-inactive");
            musBtn.innerText = isMusicOn ? "ON" : "OFF"; musBtn.className = "key-bind-btn " + (isMusicOn ? "toggle-active" : "toggle-inactive");
        }
        function toggleSoundSettings() { AudioSys.toggleSound(); updateAudioBtns(); }
        function toggleMusicSettings() { AudioSys.toggleMusic(); updateAudioBtns(); }
        function hideSettings() { document.getElementById('settings-screen').classList.add('hidden'); if(isPlaying) document.getElementById('pause-screen').classList.remove('hidden'); else document.getElementById('start-screen').classList.remove('hidden'); }
        function togglePause() { if(!isPlaying) return; isPaused = !isPaused; const pauseScreen = document.getElementById('pause-screen'); const settingsScreen = document.getElementById('settings-screen'); if(isPaused) { if(settingsScreen.classList.contains('hidden')) pauseScreen.classList.remove('hidden'); } else { pauseScreen.classList.add('hidden'); settingsScreen.classList.add('hidden'); requestAnimationFrame(animate); } }
        
        window.addEventListener('keydown', (e) => { 
            if(e.key === 'Escape') { 
                // Fix: Don't toggle pause if rebinding
                if (isRebinding) return;

                if(!document.getElementById('settings-screen').classList.contains('hidden')) hideSettings(); 
                else togglePause(); 
                return; 
            } 
            if(isPaused || isRebinding) return; 
            const k = e.key.toLowerCase(); 
            if(k === bindings.up || k === 'arrowup') activeKeys[k] = true; 
            if(k === bindings.down || k === 'arrowdown') activeKeys[k] = true; 
            if(k === bindings.left || k === 'arrowleft') activeKeys[k] = true; 
            if(k === bindings.right || k === 'arrowright') activeKeys[k] = true; 
            if(k === bindings.boost) activeKeys[k] = true; 
            if(k === bindings.fire) activeKeys[k] = true; 
        });
        window.addEventListener('keyup', (e) => { 
            const k = e.key.toLowerCase(); 
            if(k === bindings.up || k === 'arrowup') activeKeys[k] = false; 
            if(k === bindings.down || k === 'arrowdown') activeKeys[k] = false; 
            if(k === bindings.left || k === 'arrowleft') activeKeys[k] = false; 
            if(k === bindings.right || k === 'arrowright') activeKeys[k] = false; 
            if(k === bindings.boost) activeKeys[k] = false; 
            if(k === bindings.fire) activeKeys[k] = false; 
        });
        function isActionActive(actionId) { 
            if (actionId === 'up') return activeKeys[bindings.up] || activeKeys['arrowup'];
            if (actionId === 'down') return activeKeys[bindings.down] || activeKeys['arrowdown'];
            if (actionId === 'left') return activeKeys[bindings.left] || activeKeys['arrowleft'];
            if (actionId === 'right') return activeKeys[bindings.right] || activeKeys['arrowright'];
            return activeKeys[bindings[actionId]];
        }

        // --- MOBILE INPUT HELPER ---
        function setKey(action, state) {
            let key = bindings[action];
            activeKeys[key] = state;
        }

        window.addEventListener("touchend", () => {
            setKey("up", false); setKey("down", false);
            setKey("left", false); setKey("right", false);
            setKey("fire", false); setKey("boost", false);
        });
        window.addEventListener("touchcancel", () => {
            setKey("up", false); setKey("down", false);
            setKey("left", false); setKey("right", false);
            setKey("fire", false); setKey("boost", false);
        });

        // --- INIT ---
        function disposeHierarchy(obj) { 
            if (!obj) return;
            // FIX: Dispose children first
            if (obj.children) obj.children.forEach(disposeHierarchy);
            if (obj.geometry) obj.geometry.dispose();
            if (obj.material) {
                // Fix: Dispose texture maps
                if (Array.isArray(obj.material)) {
                    obj.material.forEach(m => {
                        if(m.map) m.map.dispose();
                        m.dispose();
                    });
                } else {
                    if(obj.material.map) obj.material.map.dispose();
                    obj.material.dispose();
                }
            }
        }

        function initGame() {
            AudioSys.init();
            document.getElementById('start-screen').classList.add('hidden');
            const container = document.getElementById('game-container');
            
            if (scene) {
                rings.forEach(r => { scene.remove(r); disposeHierarchy(r); });
                bullets.forEach(b => { scene.remove(b.mesh); disposeHierarchy(b.mesh); });
                repairKits.forEach(k => { scene.remove(k); disposeHierarchy(k); }); 
                enemies.forEach(e => { scene.remove(e); disposeHierarchy(e); });    
            }
            rings = []; repairKits = []; enemies = []; bullets = []; ringWaypoints = [];
            // CLEAR other players
            // FIX: Only clear meshes, keep data in MP
            if (gameMode === 'multi') {
                Object.values(otherPlayers).forEach(p => { 
                    if(p.mesh && scene) scene.remove(p.mesh);
                    if(p.mesh) disposeHierarchy(p.mesh);
                    p.mesh = null;
                });
            } else {
                Object.values(otherPlayers).forEach(p => { 
                    if(p.mesh && scene) scene.remove(p.mesh);
                    if(p.mesh) disposeHierarchy(p.mesh);
                });
                for(let k in otherPlayers) delete otherPlayers[k];
            }

            scene = new THREE.Scene(); scene.background = new THREE.Color(0x87CEEB); scene.fog = new THREE.Fog(0x87CEEB, 2000, 10000);
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 20000);
            renderer = new THREE.WebGLRenderer({ antialias: true }); renderer.setSize(window.innerWidth, window.innerHeight); renderer.shadowMap.enabled = true;
            container.innerHTML = ''; container.appendChild(renderer.domElement);
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6); scene.add(hemiLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8); dirLight.position.set(100, 200, 50); dirLight.castShadow = true; scene.add(dirLight);

            // Reset States
            playerStats.rings = 0; playerStats.progress = 0;
            enemyStats.forEach(e => { e.rings = 0; });
            enemiesAliveCount = 4;
            health = 100; boostLevel = 100;
            
            generateTerrain(); generateOcean(); createPlaneSystem(); createGuideArrow(); createRepairKits(); createRings();
            
            // Only create enemies in single player mode
            if (gameMode !== "multi") {
                createEnemies();
            } else {
                // FIX: Recreate MP meshes
                Object.keys(otherPlayers).forEach(id => {
                    const pEntry = otherPlayers[id];
                    addOtherPlayer(pEntry);
                });
            }

            updateRingVisuals(); updateLeaderboard();
            isPlaying = true; isPaused = false; animate();
        }

        function getTerrainHeight(x, z) {
            let y = Math.sin(x * 0.001) * Math.cos(z * 0.001) * 1000 + Math.sin(x * 0.005) * 200;
            if (z > -1000 && z < 1000 && x > -1000 && x < 1000) y *= 0.1;
            if (y < -150) y = -150;
            return y - 50; 
        }

        function generateTerrain() {
            const geometry = new THREE.PlaneGeometry(50000, 50000, 200, 200); geometry.rotateX(-Math.PI / 2);
            const positions = geometry.attributes.position;
            const colors = [];
            for (let i = 0; i < positions.count; i++) {
                const x = positions.getX(i); const z = positions.getZ(i);
                let y = Math.sin(x * 0.001) * Math.cos(z * 0.001) * 1000 + Math.sin(x * 0.005) * 200;
                if (z > -1000 && z < 1000 && x > -1000 && x < 1000) y *= 0.1;
                if (y < -150) y = -150;
                positions.setY(i, y);
                const color = new THREE.Color();
                if (y < -50) color.setHex(TERRAIN_COLORS.SAND); 
                else if (y < 100) color.setHex(TERRAIN_COLORS.SAND); 
                else if (y < 500) color.setHex(TERRAIN_COLORS.GRASS); 
                else if (y < 900) color.setHex(TERRAIN_COLORS.ROCK); 
                else color.setHex(TERRAIN_COLORS.SNOW);
                colors.push(color.r, color.g, color.b);
            }
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3)); geometry.computeVertexNormals();
            const mat = new THREE.MeshStandardMaterial({ vertexColors: true, roughness: 0.8, flatShading: true });
            const mesh = new THREE.Mesh(geometry, mat); mesh.position.y = -50; mesh.receiveShadow = true; scene.add(mesh);
        }

        function generateOcean() {
            const geo = new THREE.PlaneGeometry(50000, 50000); geo.rotateX(-Math.PI / 2);
            const mat = new THREE.MeshBasicMaterial({ color: TERRAIN_COLORS.WATER, transparent: true, opacity: 0.6 });
            const ocean = new THREE.Mesh(geo, mat); ocean.position.y = -80; scene.add(ocean);
        }

        function createPlaneMesh(color) {
            const group = new THREE.Group();
            const mat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.4 });
            const glass = new THREE.MeshStandardMaterial({ color: 0x00aaff, opacity: 0.6, transparent: true });
            const body = new THREE.Mesh(new THREE.CylinderGeometry(2, 4, 30, 8), mat); body.rotateX(-Math.PI/2);
            const nose = new THREE.Mesh(new THREE.ConeGeometry(2, 10, 8), mat); nose.rotateX(-Math.PI/2); nose.position.z = -20;
            const cockpit = new THREE.Mesh(new THREE.BoxGeometry(3, 3, 10), glass); cockpit.position.set(0, 2.5, -5);
            const lWing = new THREE.Mesh(new THREE.BoxGeometry(20, 0.5, 15), mat); lWing.position.set(-10, 0, 5); lWing.rotation.y = 0.3;
            const rWing = new THREE.Mesh(new THREE.BoxGeometry(20, 0.5, 15), mat); rWing.position.set(10, 0, 5); rWing.rotation.y = -0.3;
            const lTail = new THREE.Mesh(new THREE.BoxGeometry(8, 0.5, 8), mat); lTail.position.set(-5, 0, 18); lTail.rotation.y = 0.2;
            const rTail = new THREE.Mesh(new THREE.BoxGeometry(8, 0.5, 8), mat); rTail.position.set(5, 0, 18); rTail.rotation.y = -0.2;
            const lFin = new THREE.Mesh(new THREE.BoxGeometry(0.5, 8, 10), mat); lFin.position.set(-2, 4, 18); lFin.rotation.z = 0.2;
            const rFin = new THREE.Mesh(new THREE.BoxGeometry(0.5, 8, 10), mat); rFin.position.set(2, 4, 18); rFin.rotation.z = -0.2;
            const intakeGeo = new THREE.BoxGeometry(3, 4, 10);
            const lIntake = new THREE.Mesh(intakeGeo, mat); lIntake.position.set(-3.5, -1, 5);
            const rIntake = new THREE.Mesh(intakeGeo, mat); rIntake.position.set(3.5, -1, 5);
            group.add(body, nose, cockpit, lWing, rWing, lTail, rTail, lFin, rFin, lIntake, rIntake);
            return group;
        }

        function createPlaneSystem() {
            planeRig = new THREE.Group(); planeRig.position.set(0, 400, 800); scene.add(planeRig);
            planeMesh = createPlaneMesh(0x555555); planeRig.add(planeMesh);
            const glowGeo = new THREE.ConeGeometry(3, 10, 8); glowGeo.rotateX(Math.PI / 2);
            const glowMat = new THREE.MeshBasicMaterial({ color: 0x00d2ff, transparent: true, opacity: 0 });
            const glow = new THREE.Mesh(glowGeo, glowMat); glow.position.set(0, 0, 20); glow.name = "EngineGlow"; planeMesh.add(glow);
        }

        function createEnemies() {
            for(let i=0; i<4; i++) {
                const enemy = new THREE.Group();
                const mesh = createPlaneMesh(0xaa0000); 
                enemy.add(mesh);
                const offsetX = (i - 1.5) * 200;
                enemy.position.set(offsetX, 400, 400); 
                const spd = NORMAL_SPEED * (0.95 + Math.random() * 0.1); 
                enemy.userData = { alive: true, health: 300, speed: spd, progress: 0, ringLocked: false, lastShot: 0, boostUntil: 0 };
                scene.add(enemy); enemies.push(enemy);
                enemyStats[i].obj = enemy;
            }
        }

        function createGuideArrow() {
            const group = new THREE.Group();
            const mat = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.8 });
            
            // CONE + CYLINDER Shape
            const cylinder = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 15, 8), mat);
            cylinder.rotation.x = Math.PI / 2;
            cylinder.position.z = -7.5; // Sit behind the tip
            
            const cone = new THREE.Mesh(new THREE.ConeGeometry(4, 8, 8), mat);
            cone.rotation.x = Math.PI / 2;
            
            group.add(cylinder, cone);
            guideArrow = group;
            scene.add(guideArrow); 
        }

        function createRings() {
            for(let i=0; i<RINGS_PER_LAP; i++) { 
                const angle = i * (Math.PI * 2 / RINGS_PER_LAP); 
                const x = Math.sin(angle) * 12000;
                const z = Math.cos(angle) * -12000;
                const groundY = getTerrainHeight(x, z);
                const y = Math.max(500, groundY + 400);
                
                ringWaypoints.push({x:x, y:y, z:z});

                const geo = new THREE.TorusGeometry(80, 10, 16, 50); 
                const mat = new THREE.MeshPhongMaterial({ color: 0xFFD700, emissive: 0xffaa00, shininess: 100 });
                const ring = new THREE.Mesh(geo, mat);
                ring.position.set(x, y, z);
                ring.rotation.y = Math.random() * Math.PI;
                // Fix: Attach ring lock state to user data on creation
                ring.userData.locked = false;
                scene.add(ring);
                rings.push(ring); 
            }
        }

        function updateRingVisuals() {
            const currentTargetIdx = playerStats.progress % RINGS_PER_LAP; 
            rings.forEach((r, i) => {
                if (i === currentTargetIdx) {
                    r.material.emissive.setHex(0xffaa00); 
                    r.material.color.setHex(0xffd700); 
                    r.visible = true;
                    currentRingObj = r; 
                    // Fix: Reset lock when ring becomes active again
                    if (currentRingObj) currentRingObj.userData.locked = false;
                } else {
                    r.visible = false; 
                }
            });
        }

        function createRepairKits() {
            const kitGroupPrototype = new THREE.Group();
            const boxGeo = new THREE.BoxGeometry(60, 60, 60); const boxMat = new THREE.MeshPhongMaterial({ color: 0x00aa00, emissive: 0x003300, shininess: 30 });
            const box = new THREE.Mesh(boxGeo, boxMat); kitGroupPrototype.add(box);
            
            const crossMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const vBar = new THREE.Mesh(new THREE.BoxGeometry(20, 70, 20), crossMat);
            const hBar = new THREE.Mesh(new THREE.BoxGeometry(70, 20, 20), crossMat);
            const dBar = new THREE.Mesh(new THREE.BoxGeometry(20, 20, 70), crossMat);
            kitGroupPrototype.add(vBar, hBar, dBar);

            const positions = [{ x: 1000, z: -3000 }, { x: -2000, z: -6000 }, { x: 500, z: -9000 }];
            positions.forEach((loc) => {
                const groundY = getTerrainHeight(loc.x, loc.z); const y = Math.max(300, groundY + 200); 
                const kit = kitGroupPrototype.clone(); kit.position.set(loc.x, y, loc.z); kit.userData = { active: true, respawnTime: 0 };
                scene.add(kit); repairKits.push(kit);
            });
        }

        function spawnBullet() {
            AudioSys.playGun(); 
            let target = null; let minDist = Infinity;
            
            // Fix: Only auto-target enemies in Single Player
            if (gameMode !== "multi") {
                const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(planeRig.quaternion);
                enemies.forEach(e => {
                    if(e.userData.alive) {
                        const toEnemy = new THREE.Vector3().subVectors(e.position, planeRig.position);
                        const dist = toEnemy.length(); if(dist < 8000 && forward.dot(toEnemy.normalize()) > 0.7 && dist < minDist) { minDist = dist; target = e; }
                    }
                });
            }

            const bulletGeo = new THREE.SphereGeometry(2, 8, 8); const bulletMat = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
            const offsets = [-12, 12];
            offsets.forEach(offset => {
                const bullet = new THREE.Mesh(bulletGeo, bulletMat); bullet.position.copy(planeRig.position);
                const wingX = Math.cos(planeRig.rotation.y) * offset; const wingZ = Math.sin(planeRig.rotation.y) * -offset; 
                bullet.position.x += wingX; bullet.position.z += wingZ; bullet.rotation.y = planeRig.rotation.y;
                scene.add(bullet);
                const v = new THREE.Vector3(0, 0, -1).applyQuaternion(planeRig.quaternion).multiplyScalar(25);
                bullets.push({ mesh: bullet, velocity: v, target: target, life: 150 });
            });
        }

        function spawnEnemyBullet(enemy, targetPos) {
            const bulletGeo = new THREE.SphereGeometry(4, 8, 8); 
            const bulletMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const bullet = new THREE.Mesh(bulletGeo, bulletMat);
            bullet.position.copy(enemy.position);
            bullet.rotation.copy(enemy.rotation); 
            scene.add(bullet);
            
            const direction = new THREE.Vector3().subVectors(targetPos, enemy.position).normalize();
            direction.x += (Math.random() - 0.5) * 0.05;
            direction.y += (Math.random() - 0.5) * 0.05;
            direction.z += (Math.random() - 0.5) * 0.05;
            
            const v = direction.multiplyScalar(40);
            // Fix: Add owner for friendly fire protection
            bullets.push({ mesh: bullet, velocity: v, life: 400, isEnemy: true, owner: enemy }); 
            
            if (isSoundOn && Math.random() < 0.3) AudioSys.playGun();
        }

        function drawMinimap() {
            // Fix: Safety check if game is not fully initialized
            if(!minimapCtx || !planeRig) return;
            minimapCtx.clearRect(0, 0, 140, 140);
            
            const cx = 70;
            const cy = 70;
            
            // Fix: North-Up Map Mode (Rotate player arrow, not the world)
            // But we keep Heads-Up as it's better for racing. 
            // The prompt asked to fix arrow rotation (cosmetic). 
            // In Heads-Up, the player faces Up. The arrow is fixed.
            // If the user thinks it's a bug, they probably want North-Up.
            // Switching to North-Up:
            const northUp = true; 

            const range = 4000; 
            const scale = 60 / range; 

            // Draw player (arrow)
            minimapCtx.save();
            minimapCtx.translate(cx, cy);
            if (northUp) {
                // Rotate arrow based on player heading
                minimapCtx.rotate(-planeRig.rotation.y + Math.PI);
            }
            minimapCtx.beginPath();
            minimapCtx.moveTo(0, -6);
            minimapCtx.lineTo(-4, 4);
            minimapCtx.lineTo(4, 4);
            minimapCtx.fillStyle = "#00ff00";
            minimapCtx.fill();
            minimapCtx.restore();

            function drawDot(obj, color, size) {
                if(!obj || !obj.visible) return; // Fix: Added null check
                const dx = obj.position.x - planeRig.position.x;
                const dz = obj.position.z - planeRig.position.z;
                
                let px, py;

                if (northUp) {
                      // North Up: +X is Right, -Z is Up (Canvas -Y)
                      // Canvas X = dx
                      // Canvas Y = dz (since -Z in 3D is Up, so -dz is Up in canvas, which is -Y. Wait.
                      // 3D: (x, z). Canvas: (x, y). 
                      // 3D forward -Z. Canvas Up -Y.
                      // 3D right +X. Canvas Right +X.
                      // So map 3D Z to Canvas Y directly?
                      // If Z decreases (moves forward), Y decreases (moves up). Yes.
                      px = dx * scale;
                      py = dz * scale;
                } else {
                    // Heads Up logic (existing)
                    const pRot = planeRig.rotation.y;
                    const cos = Math.cos(pRot);
                    const sin = Math.sin(pRot);
                    const rx = dx * cos + dz * sin;
                    const rz = -dx * sin + dz * cos; 
                    px = rx * scale;
                    py = rz * scale;
                }

                const dist = Math.sqrt(px*px + py*py);
                if (dist > 65) {
                    const ratio = 65 / dist;
                    px *= ratio;
                    py *= ratio;
                }

                minimapCtx.beginPath();
                minimapCtx.arc(cx + px, cy + py, size, 0, Math.PI * 2);
                minimapCtx.fillStyle = color;
                minimapCtx.fill();
            }

            enemies.forEach(e => {
                if(e.userData.alive) drawDot(e, "#ff0000", 3);
            });
            
            // Show other players on minimap
            Object.values(otherPlayers).forEach(p => {
                // FIX: use p.mesh if exists
                if(p.mesh) drawDot(p.mesh, "#0000ff", 3); 
            });

            if(currentRingObj) {
                drawDot(currentRingObj, "#ffd700", 4);
            }
        }

        function animate() {
            if (!isPlaying || isPaused) return;

            // Update FPS
            frameCount++;
            const t = performance.now();
            if (t - lastFrameTime >= 1000) {
                if (fpsElem) fpsElem.innerText = "FPS: " + frameCount;
                frameCount = 0;
                lastFrameTime = t;
            }

            // --- ENEMIES LOGIC (Fixed) ---
            const now = Date.now();
            if (gameMode !== "multi") {
                enemies.forEach((e, idx) => {
                    if(e.userData.alive) {
                        
                        // --- 1. FIND NEAREST TARGET ---
                        let closestTarget = null;
                        let minDist = Infinity;

                        // Check Player
                        const distToPlayer = e.position.distanceTo(planeRig.position);
                        if (distToPlayer < 10000) { 
                            closestTarget = planeRig;
                            minDist = distToPlayer;
                        }

                        // Check other Enemies (Free For All)
                        enemies.forEach(other => {
                            if (other !== e && other.userData.alive) {
                                const d = e.position.distanceTo(other.position);
                                if (d < minDist) {
                                    minDist = d;
                                    closestTarget = other; 
                                }
                            }
                        });

                        // --- 2. DODGE LOGIC (Smart Dodge) ---
                        let isDodging = false;
                        for(let b of bullets) {
                            // Check only close bullets
                            if (b.mesh.position.distanceTo(e.position) < 500) {
                                // Check if bullet is heading towards enemy
                                const toEnemy = e.position.clone().sub(b.mesh.position).normalize();
                                const bulletDir = b.velocity.clone().normalize();
                                // Fix: Only dodge bullets heading TOWARDS enemy
                                if (bulletDir.dot(toEnemy) > 0.6) {
                                    isDodging = true;
                                    break;
                                }
                            }
                        }

                        // --- MOVEMENT LOGIC ---
                        
                        if (isDodging) {
                            e.rotation.z += 0.1; 
                            e.translateY(2);      
                            e.translateX(Math.sin(now * 0.01) * 2); 
                            e.translateZ(-e.userData.speed * 1.2); 
                            // Fix: Enemies can still shoot while dodging (fall through to shooting block)
                        } else {
                            // COMBAT vs RACE MODE
                            let targetPosVec;
                            
                            // If very close to target, engage combat mode (look at target)
                            // otherwise focus on race (look at ring)
                            if (closestTarget && minDist < 2000) {
                                targetPosVec = closestTarget.position.clone();
                            } else {
                                let targetIdx = e.userData.progress % RINGS_PER_LAP; 
                                const wp = ringWaypoints[targetIdx];
                                if (wp) targetPosVec = new THREE.Vector3(wp.x, wp.y, wp.z);
                            }

                            if (targetPosVec) {
                                // Terrain Avoidance
                                const forwardDir = new THREE.Vector3(0, 0, -1).applyQuaternion(e.quaternion); 
                                const lookAheadPoint = e.position.clone().add(forwardDir.clone().multiplyScalar(400));
                                const terrainH_ahead = getTerrainHeight(lookAheadPoint.x, lookAheadPoint.z);
                                
                                if (lookAheadPoint.y < terrainH_ahead + 250) {
                                    targetPosVec.y = Math.max(targetPosVec.y, terrainH_ahead + 400);
                                }

                                // Smooth Turning
                                const dummy = new THREE.Object3D();
                                dummy.position.copy(e.position);
                                dummy.lookAt(targetPosVec);
                                dummy.rotateY(Math.PI); 
                                e.quaternion.slerp(dummy.quaternion, 0.04);

                                // Banking
                                const fwd = new THREE.Vector3(0, 0, -1).applyQuaternion(e.quaternion);
                                const desired = targetPosVec.clone().sub(e.position).normalize();
                                const turnComponent = fwd.cross(desired).y; 
                                const targetRoll = turnComponent * 20; 
                                e.rotation.z = THREE.MathUtils.lerp(e.rotation.z, targetRoll, 0.05);

                                // Move Forward
                                if (now > e.userData.boostUntil) {
                                    if (Math.random() < 0.005) e.userData.boostUntil = now + 2000; 
                                }
                                let speed = e.userData.speed;
                                if (now < e.userData.boostUntil) speed *= 1.5;
                                e.translateZ(-speed);
                            }
                        }

                        // --- 4. SHOOTING LOGIC ---
                        if (closestTarget) {
                            const distToTarget = e.position.distanceTo(closestTarget.position);
                            if (distToTarget < 10000) {
                                if (now - (e.userData.lastShot || 0) > 2000) { 
                                    spawnEnemyBullet(e, closestTarget.position);
                                    e.userData.lastShot = now;
                                }
                            }
                        }

                        // 4. Hard Floor Safety
                        const currentH = getTerrainHeight(e.position.x, e.position.z);
                        if(e.position.y < currentH + 80) {
                            e.position.y = currentH + 80;
                            e.rotation.x -= 0.05; 
                        }

                        // 5. Ring Collection
                        let targetIdx = e.userData.progress % RINGS_PER_LAP; 
                        const wp = ringWaypoints[targetIdx];
                        if (wp) {
                            const targetPosVec = new THREE.Vector3(wp.x, wp.y, wp.z);
                            const dist = e.position.distanceTo(targetPosVec);

                            // Fix: Using boolean lock
                            if (!e.userData.ringLocked && dist < 180) {
                                e.userData.ringLocked = true;
                                setTimeout(() => e.userData.ringLocked = false, 700);
                                e.userData.progress++;
                                // Fix: Single source of truth updates
                                enemyStats[idx].rings = e.userData.progress;
                                ringCollected(enemyStats[idx].name);
                            }
                        }
                    }
                });
            }

            // --- PLAYER & BULLETS ---
            // FIX 7: Disable firing in MP because damage sync isn't implemented
            if (isActionActive('fire') && gameMode !== "multi") {
                if (now - lastFireTime > FIRE_RATE) { spawnBullet(); lastFireTime = now; }
            }

            for (let i = bullets.length - 1; i >= 0; i--) {
                const b = bullets[i];
                b.mesh.position.add(b.velocity); b.life--;
                
                const gh = getTerrainHeight(b.mesh.position.x, b.mesh.position.z);
                if (b.mesh.position.y < gh + 10) { 
                    scene.remove(b.mesh); 
                    bullets.splice(i, 1); 
                    continue; 
                }

                if (b.isEnemy) {
                    // INCREASED HITBOX TO 80
                    if (b.mesh.position.distanceTo(planeRig.position) < 80) { 
                         health -= 6; 
                         AudioSys.playExplosion(); 
                         if (health <= 0) { health = 0; endGame(false, "Shot Down!"); }
                         scene.remove(b.mesh); bullets.splice(i, 1); continue;
                    }
                    
                    // Fix: Friendly Fire Check
                    let hitEnemy = false;
                    for (let e of enemies) {
                        // Don't hit owner
                        if (e !== b.owner && e.userData.alive && b.mesh.position.distanceTo(e.position) < 80) {
                             e.userData.health -= 10;
                             AudioSys.playExplosion();
                             if(e.userData.health <= 0) {
                                 e.userData.alive = false; e.visible = false;
                                 enemiesAliveCount--;
                                 if(enemiesAliveCount === 0) endGame(true, "Enemy Resistance Neutralized");
                             }
                             hitEnemy = true;
                             break;
                        }
                    }
                    if (hitEnemy) {
                        scene.remove(b.mesh); bullets.splice(i, 1); continue;
                    }

                } else {
                    if(b.target && b.target.userData.alive) {
                        const dir = new THREE.Vector3().subVectors(b.target.position, b.mesh.position).normalize();
                        b.velocity.lerp(dir.multiplyScalar(20), 0.1);
                    }
                    let hit = false;
                    for(let e of enemies) {
                        if(e.userData.alive && b.mesh.position.distanceTo(e.position) < 80) {
                            e.userData.health -= 25; AudioSys.playExplosion();
                            if(e.userData.health <= 0) { 
                                e.userData.alive = false; e.visible = false;
                                enemiesAliveCount--;
                                if(enemiesAliveCount === 0) endGame(true, "Enemy Resistance Neutralized");
                            }
                            hit = true; break;
                        }
                    }
                    if(hit) { scene.remove(b.mesh); bullets.splice(i, 1); continue; }
                }
                
                if (b.life <= 0) { scene.remove(b.mesh); bullets.splice(i, 1); }
            }

            let currentSpeed = NORMAL_SPEED; let isBoosting = false; let engineGlow = planeMesh.getObjectByName("EngineGlow");
            if (isActionActive('boost') && boostLevel > 0) {
                currentSpeed = BOOST_SPEED; isBoosting = true;
                boostLevel -= BOOST_DRAIN; if (boostLevel < 0) boostLevel = 0;
                if(engineGlow) engineGlow.material.opacity = 0.8;
                // FIX 6: Removed duplicate camera shake here
            } else {
                if (boostLevel < 100) boostLevel += BOOST_REFILL;
                if(engineGlow) engineGlow.material.opacity = 0;
            }
            document.getElementById('boost-fill').style.width = boostLevel + '%';
            
            // Fix: Removed duplicate audio update
            // AudioSys.updateContinuousAudio(isBoosting, false); 

            planeRig.translateZ(-currentSpeed);
            
            // âœ… PART 7 â€” Movement sending ONLY in multiplayer mode (Throttled)
            if (gameMode === "multi" && socket && mp.roomId) { // Fix: Check roomId
              const nowT = performance.now();
              if (nowT - lastNetSend > 50) { // Fix: Throttle to 50ms
                  lastNetSend = nowT;
                  // Correct: Send only rig rotation (actual direction), ignore visual tilt for network to avoid doubling
                  const q = planeRig.quaternion; 

                  socket.emit("playerMovement", {
                    roomId: mp.roomId,
                    room: mp.roomId, // Add this for compatibility
                    x: planeRig.position.x,
                    y: planeRig.position.y,
                    z: planeRig.position.z,
                    // Sending quaternion instead of euler for smoother sync
                    quaternion: { 
                        x: q.x, 
                        y: q.y, 
                        z: q.z, 
                        w: q.w 
                    }
                  });
              }
            }

            if (isActionActive('left')) { planeRig.rotation.y += TURN_SPEED; visualRoll = THREE.MathUtils.lerp(visualRoll, 0.8, 0.1); }
            else if (isActionActive('right')) { planeRig.rotation.y -= TURN_SPEED; visualRoll = THREE.MathUtils.lerp(visualRoll, -0.8, 0.1); }
            else { visualRoll = THREE.MathUtils.lerp(visualRoll, 0, 0.1); }

            if (isActionActive('up')) { planeRig.position.y += LIFT_SPEED; visualPitch = THREE.MathUtils.lerp(visualPitch, -0.5, 0.1); }
            else if (isActionActive('down')) { planeRig.position.y -= LIFT_SPEED; visualPitch = THREE.MathUtils.lerp(visualPitch, 0.5, 0.1); }
            else { visualPitch = THREE.MathUtils.lerp(visualPitch, 0, 0.1); }

            const groundHeight = getTerrainHeight(planeRig.position.x, planeRig.position.z);
            let isDamaging = false;
            if (planeRig.position.y < groundHeight + 15) {
                planeRig.position.y = groundHeight + 15; health -= COLLISION_DAMAGE; isDamaging = true;
                if (health <= 0) { health = 0; endGame(false, "Crashed"); }
            }
            AudioSys.updateContinuousAudio(isBoosting, isDamaging);
            document.getElementById('health-fill').style.width = health + '%';
            
            planeMesh.rotation.z = visualRoll; planeMesh.rotation.x = visualPitch;
            const targetCamPos = new THREE.Vector3(0, 100, 300).applyMatrix4(planeRig.matrixWorld);
            
            // Fix: Camera Drift
            // We lerp to target but add shake as a non-accumulative offset to visual X/Y?
            // Actually, simply snapping X to target+shake prevents drift, but reduces smoothness.
            // The provided fix in reasoning was `camera.position.x = targetCamPos.x + shake`.
            // But we want to maintain some smoothness.
            // Let's compromise: lerp first, then apply shake without +=.
            camera.position.lerp(targetCamPos, 0.1); 
            if (isBoosting) {
                camera.position.x += (Math.random() - 0.5) * 2;
                camera.position.y += (Math.random() - 0.5) * 2;
                // Note: += on lerped position technically drifts if lerp is slow, but resets every frame towards target.
                // The real drift happens if targetCamPos depends on camera.position (it doesn't).
                // However, user insisted it drifts. Let's force X to ensure no drift.
                // camera.position.x = targetCamPos.x + (Math.random() - 0.5) * 2; 
                // But this snaps. Let's leave it as is, or use the `camera.position.x =` approach if user insists.
                // User said "Camera shake still drifts camera... Fix: camera.position.x = targetCamPos.x + shake".
                // I will apply this fix.
                const shake = (Math.random() - 0.5) * 2;
                camera.position.x = targetCamPos.x + shake;
            }

            camera.lookAt(planeRig.position);

            if (currentRingObj) {
                guideArrow.visible = true; guideArrow.position.copy(planeRig.position); guideArrow.position.y += 60; 
                guideArrow.lookAt(currentRingObj.position);
                
                // Fix: Ring lock attached to object
                if (planeRig.position.distanceTo(currentRingObj.position) < 100 && !currentRingObj.userData.locked) {
                    currentRingObj.userData.locked = true;
                    ringCollected("PLAYER");
                }
            } else { guideArrow.visible = false; }
            
            repairKits.forEach(kit => {
                if (kit.userData.active) {
                    kit.rotation.y += 0.02;
                    if (planeRig.position.distanceTo(kit.position) < 80) { 
                        kit.userData.active = false; kit.visible = false; kit.userData.respawnTime = Date.now() + 30000; 
                        health += 30; if(health > 100) health = 100; AudioSys.playRepair();
                    }
                } else if (Date.now() > kit.userData.respawnTime) { kit.userData.active = true; kit.visible = true; }
            });

            rings.forEach(r => r.rotation.z += 0.01);
            
            // Draw Minimap
            drawMinimap();

            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }

        function endGame(win, reason) {
            isPlaying = false; AudioSys.stopAll();
            const screen = document.getElementById('end-screen'); const title = document.getElementById('end-title'); const msg = document.getElementById('end-msg');
            if (win) { title.innerText = "VICTORY"; title.className = "win-text"; msg.innerText = reason || "Race Champion!"; } 
            else { title.innerText = "DEFEAT"; title.className = "lose-text"; msg.innerText = reason || "Enemy Won the Race."; }
            screen.classList.remove('hidden');
        }

        window.addEventListener('resize', () => {
            if (camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        });
    </script>
</body>
</html>
