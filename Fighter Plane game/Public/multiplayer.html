<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Sky Pilot - Multiplayer</title>

  <!-- Socket.IO client -->
  <script src="https://cdn.socket.io/4.7.4/socket.io.min.js"></script>
  <!-- THREE.JS LIBRARY -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  
  <!-- Global Managers & Config -->
  <!-- ✅ Fix 1: Exact filenames and ensuring config is loaded first -->
  <script src="game-config.js"></script>
  <script src="game-manager.js"></script>
  <script src="sfx-manager.js"></script>
  <script src="music-manager.js"></script>

  <style>
    body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; user-select: none; touch-action: none; }
    #game-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }

    #ui-layer {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      pointer-events: none;
      /* ✅ Fix 8: Hide UI initially (Lobby/Countdown) */
      display: none; 
      flex-direction: column; justify-content: space-between;
      padding: 20px; box-sizing: border-box;
    }

    .hud-top { display: flex; justify-content: space-between; align-items: flex-start; }
    .left-hud { display: flex; flex-direction: column; align-items: flex-start; gap: 15px; }
    .right-hud { display: flex; flex-direction: column; align-items: flex-end; gap: 10px; pointer-events: auto; }
    .top-right-row { display: flex; align-items: flex-start; gap: 15px; }

    .leaderboard-box {
      background: rgba(0,0,0,0.6); padding: 15px; border-radius: 10px;
      color: white; min-width: 220px; pointer-events: none; backdrop-filter: blur(4px);
      border-left: 5px solid #ffd700;
    }
    .lb-title { font-weight: 900; font-size: 14px; color: #ffd700; border-bottom: 1px solid #555; padding-bottom: 5px; margin-bottom: 8px; letter-spacing: 1px; }
    .lb-row { display: flex; justify-content: space-between; font-size: 14px; margin-bottom: 4px; font-weight: bold; }
    .lb-name { color: #ddd; }
    .lb-score { color: #fff; font-family: monospace; }
    .lb-player { color: #00ff00; text-shadow: 0 0 5px #00ff00; }
    .lb-rank-1 { color: #ffd700; }

    .pause-btn { background: rgba(0,0,0,0.6); color: white; border: 2px solid white; width: 40px; height: 40px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; cursor: pointer; transition: 0.2s; }
    .pause-btn:hover { background: white; color: black; box-shadow: 0 0 15px white; }

    .bar-container { width: 220px; text-align: left; pointer-events: none; }
    .right-hud .bar-container { text-align: right; }
    .bar-label { font-weight: 900; font-size: 14px; margin-bottom: 3px; letter-spacing: 1px; text-shadow: 0 0 5px black; }
    .bar-bg { width: 100%; height: 12px; background: rgba(0,0,0,0.6); border: 1px solid #444; border-radius: 6px; overflow: hidden; transform: skewX(-20deg); box-shadow: 0 0 5px rgba(0,0,0,0.5); }
    .health-label { color: #00ff00; text-shadow: 0 0 10px #00ff00; }
    #health-fill { width: 100%; height: 100%; background: linear-gradient(90deg, #cc0000, #00ff00); box-shadow: 0 0 10px #00ff00; transition: width 0.1s linear; }
    .boost-label { color: #00d2ff; text-shadow: 0 0 10px #00d2ff; }
    #boost-fill { width: 100%; height: 100%; background: linear-gradient(90deg, #0066ff, #00d2ff); box-shadow: 0 0 15px #00d2ff; transition: width 0.1s linear; }

    #fps-counter {
      background: rgba(0,0,0,0.5);
      color: #00ff00;
      padding: 5px 10px;
      border-radius: 5px;
      font-family: monospace;
      font-weight: bold;
      font-size: 12px;
      pointer-events: none;
      margin-bottom: 5px;
    }

    #respawn-msg {
        position: absolute; top: 30%; width: 100%; text-align: center;
        color: #ff4444; font-size: 40px; font-weight: 900; text-shadow: 0 0 20px black;
        display: none; animation: blink 0.5s infinite alternate;
    }
    @keyframes blink { from { opacity: 1; } to { opacity: 0.2; } }

    #minimap-container {
      position: absolute;
      bottom: 20px; left: 20px;
      width: 140px; height: 140px;
      background: rgba(0,10,30,0.8);
      border: 2px solid #00d2ff;
      border-radius: 50%;
      overflow: hidden;
      pointer-events: none;
      box-shadow: 0 0 15px rgba(0,210,255,0.3);
    }
    #minimap-canvas { width: 100%; height: 100%; }

    /* MOBILE CONTROLS (Fixed: Added ontouchcancel) */
    .mobile-controls {
        display: none; 
        position: absolute; bottom: 20px; width: 100%; 
        padding: 0 20px; box-sizing: border-box;
        justify-content: space-between; pointer-events: none;
        z-index: 100;
    }
    @media (max-width: 1024px) { .mobile-controls { display: flex; } }

    .control-group { pointer-events: auto; display: flex; gap: 10px; }
    .dpad { display: grid; grid-template-columns: 60px 60px 60px; grid-template-rows: 60px 60px; gap: 5px; }
    .mob-btn {
        width: 60px; height: 60px; background: rgba(255,255,255,0.1);
        border: 2px solid rgba(255,255,255,0.3); border-radius: 50%;
        color: white; font-weight: bold; font-size: 20px;
        display: flex; align-items: center; justify-content: center;
        user-select: none; -webkit-user-select: none;
        backdrop-filter: blur(4px);
    }
    .mob-btn:active { background: rgba(0, 210, 255, 0.4); border-color: #00d2ff; transform: scale(0.95); }
    .mob-btn-rect { width: 80px; height: 60px; border-radius: 15px; font-size: 14px; }
    .mob-fire { border-color: #ff4444; } .mob-fire:active { background: rgba(255, 0, 0, 0.3); }
    .mob-boost { border-color: #00d2ff; }
      
    .btn-up { grid-column: 2; grid-row: 1; }
    .btn-left { grid-column: 1; grid-row: 2; }
    .btn-down { grid-column: 2; grid-row: 2; }
    .btn-right { grid-column: 3; grid-row: 2; }

    /* Screens */
    .screen {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.5);
      backdrop-filter: blur(8px);
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      pointer-events: auto; z-index: 10;
    }
    .hidden { display: none !important; }

    .menu-box {
      background: rgba(12, 20, 30, 0.85);
      border: 2px solid #00d2ff;
      border-radius: 20px;
      padding: 40px;
      text-align: center;
      box-shadow: 0 0 50px rgba(0, 210, 255, 0.25), inset 0 0 30px rgba(0, 210, 255, 0.1);
      width: 550px;
      max-width: 90%;
      max-height: 90vh;
      overflow-y: auto;
      animation: glowPulse 4s infinite alternate;
    }
    @keyframes glowPulse {
      from { box-shadow: 0 0 30px rgba(0, 210, 255, 0.2); }
      to { box-shadow: 0 0 60px rgba(0, 210, 255, 0.4); }
    }

    h1 { font-size: 56px; color: #fff; text-transform: uppercase; margin: 0 0 10px 0; font-weight: 900; letter-spacing: 4px; text-shadow: 0 0 20px #00d2ff; font-style: italic; }
    h2 { color: #00d2ff; font-weight: 300; margin-bottom: 30px; letter-spacing: 4px; font-size: 18px; text-transform: uppercase; }

    .action-btn {
      display: block; width: 100%; padding: 18px 0; margin: 15px 0;
      background: linear-gradient(135deg, #00d2ff, #0077ff);
      border: none; color: #fff; border-radius: 50px;
      font-size: 20px; font-weight: 900; cursor: pointer;
      text-transform: uppercase; letter-spacing: 2px;
      box-shadow: 0 5px 20px rgba(0, 210, 255, 0.4);
      transition: all 0.2s cubic-bezier(0.25, 0.8, 0.25, 1);
      position: relative; overflow: hidden;
    }
    .action-btn:hover { transform: translateY(-2px) scale(1.02); box-shadow: 0 10px 40px rgba(0, 210, 255, 0.6); filter: brightness(1.2); }
    .action-btn:active { transform: translateY(1px); }

    .secondary-btn { background: rgba(255,255,255,0.05); border: 1px solid #555; box-shadow: none; font-size: 16px; }
    .secondary-btn:hover { background: rgba(255,255,255,0.15); border-color: #fff; }

    .win-text { color: #00ff00; font-size: 60px; text-shadow: 0 0 30px #00ff00; font-weight: 900; }
    .lose-text { color: #ff4444; font-size: 60px; text-shadow: 0 0 30px #ff4444; font-weight: 900; }

    input { margin-top: 10px; padding: 12px; width: 80%; border-radius: 5px; border: none; background: rgba(255,255,255,0.1); color: #fff; font-size: 16px; font-weight: bold; text-align: center; }
  </style>
</head>
<body>

  <div id="game-container"></div>
  <div id="respawn-msg">SYSTEM FAILURE - REBOOTING</div>

  <div id="ui-layer">
    <div class="hud-top">
      <div class="left-hud">
        <div id="fps-counter">FPS: 0</div>
        <div class="bar-container">
          <div class="bar-label health-label">HEALTH</div>
          <div class="bar-bg"><div id="health-fill"></div></div>
        </div>
        <div class="leaderboard-box">
          <div class="lb-title">RACE RANKING</div>
          <div id="leaderboard-list"></div>
        </div>
      </div>
      <div class="right-hud">
        <div class="top-right-row">
          <div class="bar-container">
            <div class="bar-label boost-label">BOOST</div>
            <div class="bar-bg"><div id="boost-fill"></div></div>
          </div>
          <div class="pause-btn" onclick="togglePause()">||</div>
        </div>
      </div>
    </div>
      
    <div id="minimap-container"><canvas id="minimap-canvas" width="140" height="140"></canvas></div>

    <!-- MOBILE CONTROLS (Fixed: Added ontouchcancel) -->
    <div class="mobile-controls">
        <div class="control-group dpad">
            <div class="mob-btn btn-up" 
                 ontouchstart="setKey('up', true)" 
                 ontouchend="setKey('up', false)" 
                 ontouchcancel="setKey('up', false)">▲</div>
            <div class="mob-btn btn-left" 
                 ontouchstart="setKey('left', true)" 
                 ontouchend="setKey('left', false)" 
                 ontouchcancel="setKey('left', false)">◀</div>
            <div class="mob-btn btn-down" 
                 ontouchstart="setKey('down', true)" 
                 ontouchend="setKey('down', false)" 
                 ontouchcancel="setKey('down', false)">▼</div>
            <div class="mob-btn btn-right" 
                 ontouchstart="setKey('right', true)" 
                 ontouchend="setKey('right', false)" 
                 ontouchcancel="setKey('right', false)">▶</div>
        </div>
        <div class="control-group" style="flex-direction: column; justify-content: flex-end;">
            <div class="mob-btn mob-btn-rect mob-fire" 
                 ontouchstart="setKey('fire', true)" 
                 ontouchend="setKey('fire', false)" 
                 ontouchcancel="setKey('fire', false)">FIRE</div>
            <div class="mob-btn mob-btn-rect mob-boost" 
                 ontouchstart="setKey('boost', true)" 
                 ontouchend="setKey('boost', false)" 
                 ontouchcancel="setKey('boost', false)">BOOST</div>
        </div>
    </div>
  </div>

  <!-- MULTIPLAYER MENU -->
  <div id="mp-menu-screen" class="screen">
    <div class="menu-box">
      <h1>MULTIPLAYER</h1>
      <button class="action-btn" onclick="mpCreateRoom()">CREATE ROOM</button>
      <div style="margin-top:15px;"></div>
      <input id="mp-room-code" placeholder="Enter Room Code e.g. ABCD" />
      <button class="action-btn secondary-btn" onclick="mpJoinRoom()">JOIN ROOM</button>
      <button class="action-btn secondary-btn" onclick="window.location.href='index.html'">BACK</button>
    </div>
  </div>

  <!-- LOBBY SCREEN -->
  <div id="lobby-screen" class="screen hidden">
    <div class="menu-box">
      <h1>LOBBY</h1>
      <div style="color:#00d2ff; font-weight:800; margin:10px 0;">ROOM: <span id="lobby-room-id">----</span></div>
      <div style="text-align:left; margin-top:10px;">
        <div style="color:#fff; font-weight:900; margin-bottom:8px;">PLAYERS</div>
        <div id="lobby-player-list" style="color:#ddd; font-family:monospace;"></div>
      </div>
      <button id="host-start-btn" class="action-btn hidden" onclick="mpHostStartGame()">START GAME</button>
      <button class="action-btn secondary-btn" onclick="mpLeaveLobby()">LEAVE</button>
    </div>
  </div>

  <!-- COUNTDOWN -->
  <div id="countdown-screen" class="screen hidden">
    <div class="menu-box">
      <h1 id="countdown-text" style="font-size:90px;">3</h1>
      <p style="color:#00d2ff; font-weight:800;">GET READY</p>
    </div>
  </div>

  <!-- PAUSE -->
  <div id="pause-screen" class="screen hidden">
    <div class="menu-box">
      <h1>PAUSED</h1>
      <button class="action-btn" onclick="togglePause()">RESUME FLIGHT</button>
      <button class="action-btn secondary-btn" style="border-color:#ff4444; color:#ff4444;" onclick="location.reload()">ABORT / MAIN MENU</button>
    </div>
  </div>

  <!-- END -->
  <div id="end-screen" class="screen hidden">
    <div class="menu-box">
      <h1 id="end-title" class="win-text">VICTORY</h1>
      <p id="end-msg" style="color:#fff; font-size: 20px;">GG</p>
      <button class="action-btn" onclick="location.reload()">RE-ENGAGE / MAIN MENU</button>
    </div>
  </div>

<script>
  // --- LOAD FROM GLOBAL CONFIG ---
  const { 
      RINGS_PER_LAP, 
      TOTAL_RINGS_WIN, 
      NORMAL_SPEED, 
      BOOST_SPEED, 
      TURN_SPEED, 
      LIFT_SPEED, 
      FIRE_RATE, 
      COLLISION_DAMAGE, 
      BOOST_DRAIN, 
      BOOST_REFILL, 
      TERRAIN_COLORS 
  } = window.SKY_CONFIG || {
      // Fallback
      RINGS_PER_LAP: 12, TOTAL_RINGS_WIN: 12, NORMAL_SPEED: 5, BOOST_SPEED: 10,
      TURN_SPEED: 0.03, LIFT_SPEED: 5, FIRE_RATE: 120, COLLISION_DAMAGE: 8,
      BOOST_DRAIN: 0.5, BOOST_REFILL: 0.1, TERRAIN_COLORS: { SAND: 0xeebb88, GRASS: 0x55aa55, ROCK: 0x666666, SNOW: 0xffffff, WATER: 0x004488 }
  };

  const WORLD_LIMIT = 24500; 

  // Touch scroll lock
  let touchLocked = false;
  function preventTouch(e) { e.preventDefault(); }
  function lockTouchScroll() {
    if(touchLocked) return;
    touchLocked = true;
    document.body.addEventListener("touchmove", preventTouch, { passive: false });
  }

  // ✅ Fix 1: Safe SFX Checker
  function isSfxEnabled() {
    if (window.GameManager && window.GameManager.data) return !!window.GameManager.data.sfx;
    return true; // fallback to true if manager missing
  }

  // --- SHARED BULLET ASSETS ---
  const BULLET_GEO = new THREE.SphereGeometry(2, 8, 8);
  const BULLET_MAT_MY = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
  const BULLET_MAT_ENEMY = new THREE.MeshBasicMaterial({ color: 0xff0000 });
  // ✅ Fix 15: Reduced speed for reliability
  const BULLET_SPEED = 4000; 

  // --- SEEDED RNG ---
  let gameSeed = 12345;
  function seededRandom() {
    gameSeed = (gameSeed * 9301 + 49297) % 233280;
    return gameSeed / 233280;
  }

  // --- MP STATE ---
  let gameMode = "multi";
  let mp = { roomId: null, isHost: false, inLobby: false, playerName: null };
  const otherPlayers = {};      
  const playersData = {}; 
  const allScores = {}; 
  let lastNetworkTick = 0;
  const NETWORK_TICK_RATE = 50; 
  let lastCrashTime = 0; 
  
  // ✅ Fix 4: Ring Claim Lock (Debounce)
  let ringClaimLocked = false;

  // ✅ Fix 2: Explicit Socket URL for Render/Localhost compatibility
  let socket; 
  if (typeof io !== "undefined") {
      // ✅ Bug 7 Fix: Safe origin check using config or window location
      const SOCKET_URL = window.SKY_CONFIG?.SOCKET_URL || window.location.origin;
      socket = io(SOCKET_URL, { transports: ["websocket"] });
      // ✅ Bug 3: Debug Logger
      socket.onAny((event, ...args) => console.log("SOCKET EVENT:", event, args));
  } else { 
      console.warn("Socket.io not found - Multiplayer disabled locally");
      socket = { emit() {}, on() {}, off() {}, onAny() {} }; 
  }

  // --- OPTIMIZATION VARS ---
  let lastRender = 0;
  const FPS_CAP = 60;
  const FRAME_TIME = 1000 / FPS_CAP;

  // --- SCREEN HELPERS ---
  function showScreen(id) { document.querySelectorAll(".screen").forEach(s => s.classList.add("hidden")); const el = document.getElementById(id); if (el) el.classList.remove("hidden"); }
  function lobbyRenderPlayers(players) { const list = document.getElementById("lobby-player-list"); list.innerHTML = ""; players.forEach((p, i) => { const row = document.createElement("div"); row.textContent = `${i+1}. ${p.name}${p.isHost ? " (HOST)" : ""}`; list.appendChild(row); }); }
   
  function mpCreateRoom() { 
      if (typeof SFXManager !== 'undefined') SFXManager.init(); 
      if (typeof MusicManager !== 'undefined') MusicManager.init();
      // ✅ Fix 9: Empty Name Bug Fix
      mp.playerName = (prompt("Enter your name:", "ACE") || "").trim() || "ACE"; 
      socket.emit("mp_create_room", { name: mp.playerName }); 
  }
   
  function mpJoinRoom() { 
      if (typeof SFXManager !== 'undefined') SFXManager.init(); 
      if (typeof MusicManager !== 'undefined') MusicManager.init();
      mp.playerName = (prompt("Enter your name:", "ROOKIE") || "").trim() || "ROOKIE"; 
      const room = (document.getElementById("mp-room-code").value || "").trim(); 
      if (!room) return alert("Enter Room Code"); 
      socket.emit("mp_join_room", { roomId: room, name: mp.playerName }); 
  }

  function mpLeaveLobby() { 
      if (!mp.roomId) return showScreen("mp-menu-screen"); 
      // ✅ Fix 8: Hide UI on leave
      document.getElementById("ui-layer").style.display = "none";
      
      Object.values(otherPlayers).forEach(p => { 
          if (scene) scene.remove(p); 
          disposeHierarchy(p); 
      }); 
      for (let k in otherPlayers) delete otherPlayers[k]; 
      
      for (let k in playersData) delete playersData[k];
      for (let k in allScores) delete allScores[k];

      socket.emit("mp_leave_room", { roomId: mp.roomId }); 
      mp.roomId = null; 
      mp.isHost = false; 
      mp.inLobby = false; 
      showScreen("mp-menu-screen"); 
  }
   
  // ✅ Fix 18: Audio init on start
  function mpHostStartGame() { 
      if (typeof SFXManager !== 'undefined') SFXManager.init(); 
      if (!mp.isHost) return; 
      const seed = Math.floor(Math.random() * 100000);
      socket.emit("mp_start_game", { roomId: mp.roomId, seed: seed }); 
  }
   
  function mpCountdownThenStart() { let n = 3; const txt = document.getElementById("countdown-text"); txt.innerText = n; const timer = setInterval(() => { n--; if (n > 0) txt.innerText = n; else if (n === 0) txt.innerText = "GO!"; else { clearInterval(timer); initMultiplayerGame(); } }, 1000); }
  function initMultiplayerGame() { initGame(); document.getElementById("mp-menu-screen").classList.add("hidden"); document.getElementById("lobby-screen").classList.add("hidden"); document.getElementById("countdown-screen").classList.add("hidden"); document.getElementById("pause-screen").classList.add("hidden"); document.getElementById("end-screen").classList.add("hidden"); }

  // --- SOCKET EVENTS ---
  // ✅ Fix: Prevent Double Listeners with .off()
  socket.off("connect"); socket.on("connect", () => console.log("Connected:", socket.id));
  
  socket.off("mp_room_created");
  socket.on("mp_room_created", ({ roomId, players, hostId }) => { mp.roomId = roomId; mp.isHost = (socket.id === hostId); mp.inLobby = true; document.getElementById("lobby-room-id").innerText = roomId; lobbyRenderPlayers(players); document.getElementById("host-start-btn").classList.toggle("hidden", !mp.isHost); showScreen("lobby-screen"); });
  
  socket.off("mp_room_joined");
  socket.on("mp_room_joined", ({ roomId, players, hostId }) => { mp.roomId = roomId; mp.isHost = (socket.id === hostId); mp.inLobby = true; document.getElementById("lobby-room-id").innerText = roomId; lobbyRenderPlayers(players); document.getElementById("host-start-btn").classList.toggle("hidden", !mp.isHost); showScreen("lobby-screen"); });
  
  socket.off("mp_lobby_update");
  socket.on("mp_lobby_update", ({ roomId, players, hostId }) => { if (mp.roomId !== roomId) return; mp.isHost = (socket.id === hostId); lobbyRenderPlayers(players); document.getElementById("host-start-btn").classList.toggle("hidden", !mp.isHost); });
  
  socket.off("mp_error");
  socket.on("mp_error", (msg) => alert(msg || "Multiplayer error"));
   
  socket.off("mp_game_starting");
  socket.on("mp_game_starting", (data) => { 
      // ✅ Fix 12: Seed sync
      if(data && data.seed !== undefined) gameSeed = data.seed;
      showScreen("countdown-screen"); 
      mpCountdownThenStart(); 
  });

  socket.off("currentPlayers");
  socket.on("currentPlayers", (players) => { 
      Object.keys(players).forEach((id) => { 
          if (players[id].playerId === socket.id) return; 
          addOtherPlayer(players[id]); 
          allScores[id] = { name: players[id].name, rings: 0 };
      }); 
      allScores[socket.id] = { name: mp.playerName, rings: 0 };
  });

  socket.off("newPlayer");
  socket.on("newPlayer", (playerInfo) => {
      addOtherPlayer(playerInfo);
      allScores[playerInfo.playerId] = { name: playerInfo.name, rings: 0 };
  });

  socket.off("playerDisconnected");
  socket.on("playerDisconnected", (playerId) => {
      removeOtherPlayer(playerId);
      delete allScores[playerId];
      updateLeaderboard();
  });
   
  socket.off("playerMoved");
  socket.on("playerMoved", (playerInfo) => { 
      // ✅ Fix 10: Server must send playerMoved with quaternion always
      if (!playerInfo.quaternion) return;

      const id = playerInfo.playerId || playerInfo.id;
      if (!id) return;
      playerInfo.playerId = id; 

      if (!otherPlayers[id]) { if(scene) addOtherPlayer(playerInfo); return; }
      const p = otherPlayers[id]; // This is now a Group wrapping the mesh
      
      const snapshot = {
          time: playerInfo.ts || Date.now(), 
          pos: new THREE.Vector3(playerInfo.x, playerInfo.y, playerInfo.z),
          quat: new THREE.Quaternion(playerInfo.quaternion.x, playerInfo.quaternion.y, playerInfo.quaternion.z, playerInfo.quaternion.w),
          roll: playerInfo.rotZ || 0,
          pitch: playerInfo.rotX || 0
      };
      
      if (!p.userData.buffer) p.userData.buffer = [];
      p.userData.buffer.push(snapshot);
      // ✅ Fix 9: Sort buffer
      p.userData.buffer.sort((a,b)=>a.time-b.time);
      if (p.userData.buffer.length > 8) p.userData.buffer.shift();
  });

  socket.off("mp_game_over");
  socket.on('mp_game_over', ({ winnerName, winnerId }) => {
      const isMe = (winnerId === socket.id);
      if (isMe) { endGame(true, "You are the Race Champion!"); } else { endGame(false, `${winnerName} Won the Race!`); }
  });

  socket.off("mp_score_update");
  socket.on('mp_score_update', ({ playerId, rings, nextRingIndex }) => {
      if (allScores[playerId]) {
          allScores[playerId].rings = rings;
          updateLeaderboard();
          if(playerId === socket.id) {
              // ✅ Fix 5: Unlock on confirmation
              ringClaimLocked = false;
              playerStats.rings = rings;
              playerStats.progress = (nextRingIndex !== undefined) ? nextRingIndex : rings; 
              updateRingVisuals();
              if (typeof SFXManager !== 'undefined') SFXManager.playRing(isSfxEnabled()); 
          }
      }
  });

  // ✅ New listener for rejected rings to prevent stuck lock + Re-sync
  socket.off("mp_ring_reject");
  socket.on("mp_ring_reject", ({ expectedIndex }) => {
      console.warn("Ring rejected. Expected:", expectedIndex);
      ringClaimLocked = false; 

      // ✅ Re-sync client state
      if (typeof expectedIndex === "number") {
          playerStats.progress = expectedIndex;
          updateRingVisuals();
      }
  });

  // ✅ Fix D: Bullet Server Authoritative Event
  socket.off("mp_player_fire");
  socket.on('mp_player_fire', (data) => {
      if (data.shooterId === socket.id) return;
      const startPos = new THREE.Vector3(data.startPos.x, data.startPos.y, data.startPos.z);
      const quaternion = new THREE.Quaternion(data.quaternion.x, data.quaternion.y, data.quaternion.z, data.quaternion.w);
      spawnNetworkBullet(startPos, quaternion, data.shooterId);
  });

  socket.off("mp_kit_collected");
  socket.on('mp_kit_collected', ({ kitIndex, collectorId }) => {
      if (repairKits[kitIndex]) {
          repairKits[kitIndex].visible = false;
          // ✅ Fix 6: reliable active state
          repairKits[kitIndex].userData.active = false;
          // ✅ Fix 7: Local timer backup
          repairKits[kitIndex].userData.respawnTime = Date.now() + 30000;
          
          if(collectorId === socket.id) {
              health += 30; if(health > 100) health = 100; 
              if (typeof SFXManager !== 'undefined') SFXManager.playRepair(isSfxEnabled()); 
          }
      }
  });

  socket.off("mp_kit_restored");
  socket.on('mp_kit_restored', ({ kitIndex }) => {
      if (repairKits[kitIndex]) {
          repairKits[kitIndex].visible = true;
          repairKits[kitIndex].userData.active = true;
          repairKits[kitIndex].userData.respawnTime = 0;
      }
  });

  // ✅ Fix 3: Structure Update - Wrap mesh in a Rig Group for correct rotation
  function addOtherPlayer(playerInfo) { 
      const id = playerInfo.playerId || playerInfo.id;
      if (!id) return;
      
      playerInfo.playerId = id;
      playersData[id] = playerInfo;

      if (scene && !otherPlayers[id]) {
          const rig = new THREE.Group(); // Parent for position/heading
          const meshGroup = createPlaneMesh(0xff0000); // Visuals
          rig.add(meshGroup);
          
          rig.userData = { buffer: [] };
          const x = (playerInfo.x !== undefined) ? playerInfo.x : 0; 
          const y = (playerInfo.y !== undefined) ? playerInfo.y : 400; 
          const z = (playerInfo.z !== undefined) ? playerInfo.z : 0;
          rig.position.set(x, y, z);
          scene.add(rig); 
          otherPlayers[id] = rig; 
          
          if (!allScores[id]) allScores[id] = { name: playerInfo.name || "Pilot", rings: 0 };
      }
  }
  function removeOtherPlayer(playerId) { delete playersData[playerId]; if (!otherPlayers[playerId]) return; disposeHierarchy(otherPlayers[playerId]); if(scene) scene.remove(otherPlayers[playerId]); delete otherPlayers[playerId]; }

  // --- GAME ---
  let scene, camera, renderer, planeRig, planeMesh, guideArrow;
  let rings = [], ringWaypoints = [], currentRingObj = null, repairKits = [], bullets = [];
  let terrainMesh, oceanMesh; 
  let isPlaying = false, isPaused = false;
  let boostLevel = 100, health = 100;
  let lastFireTime = 0;
  const activeKeys = {}; let visualRoll = 0; let visualPitch = 0;
  let playerStats = { name: "PLAYER", rings: 0, progress: 0 };
  let lastFrameTime = performance.now(); let frameCount = 0; const fpsElem = document.getElementById('fps-counter');
  const minimapCanvas = document.getElementById('minimap-canvas'); const minimapCtx = minimapCanvas.getContext('2d');

  function togglePause() { 
      if (!isPlaying) return;
      isPaused = !isPaused;
      const pauseScreen = document.getElementById("pause-screen");

      if (isPaused) {
        pauseScreen.classList.remove("hidden");
      } else {
        pauseScreen.classList.add("hidden");
        requestAnimationFrame(animate);
      }
  }
   
  // --- INPUT HANDLING ---
  function getBindings() {
      if (window.GameManager && window.GameManager.data && window.GameManager.data.bindings) {
          return window.GameManager.data.bindings;
      }
      return { up:'w', down:'s', left:'a', right:'d', boost:' ', fire:'shift' };
  }

  function setKey(action, state) { 
      const binds = getBindings();
      if(action === "boost") {
        activeKeys[binds.boost] = state;
        activeKeys["Space"] = state; 
        return;
      }
      if(action === "fire") {
        activeKeys[binds.fire] = state;
        activeKeys["shift"] = state; 
        activeKeys["Shift"] = state; 
        return;
      }
      let key = binds[action];
      activeKeys[key] = state;
  }

  window.addEventListener('keydown', (e) => {
    if(e.key === "Escape") { togglePause(); return; }
    if(isPaused) return;
    const binds = getBindings();
    const k = e.key.toLowerCase();
    if(k === binds.up || k === 'arrowup') activeKeys[binds.up] = true;
    if(k === binds.down || k === 'arrowdown') activeKeys[binds.down] = true;
    if(k === binds.left || k === 'arrowleft') activeKeys[binds.left] = true;
    if(k === binds.right || k === 'arrowright') activeKeys[binds.right] = true;
    if(k === binds.boost || (binds.boost === ' ' && e.code === 'Space')) activeKeys[binds.boost] = true;
    if(k === binds.fire || (binds.fire === 'shift' && (e.code === 'ShiftLeft' || e.code === 'ShiftRight'))) activeKeys[binds.fire] = true;
  });

  window.addEventListener('keyup', (e) => {
    const binds = getBindings();
    const k = e.key.toLowerCase();
    if(k === binds.up || k === 'arrowup') activeKeys[binds.up] = false;
    if(k === binds.down || k === 'arrowdown') activeKeys[binds.down] = false;
    if(k === binds.left || k === 'arrowleft') activeKeys[binds.left] = false;
    if(k === binds.right || k === 'arrowright') activeKeys[binds.right] = false;
    if(k === binds.boost || (binds.boost === ' ' && e.code === 'Space')) activeKeys[binds.boost] = false;
    if(k === binds.fire || (binds.fire === 'shift' && (e.code === 'ShiftLeft' || e.code === 'ShiftRight'))) activeKeys[binds.fire] = false;
  });
  
  function isActionActive(actionId) { 
      const binds = getBindings();
      if (actionId === 'up') return activeKeys[binds.up] || activeKeys['arrowup']; 
      if (actionId === 'down') return activeKeys[binds.down] || activeKeys['arrowdown']; 
      if (actionId === 'left') return activeKeys[binds.left] || activeKeys['arrowleft']; 
      if (actionId === 'right') return activeKeys[binds.right] || activeKeys['arrowright']; 
      if (actionId === 'boost') return activeKeys[binds.boost] || activeKeys[" "] || activeKeys["Space"];
      if (actionId === 'fire') return activeKeys[binds.fire] || activeKeys["shift"] || activeKeys["Shift"];
      return activeKeys[binds[actionId]]; 
  }
   
  function updateLeaderboard() { 
      const list = document.getElementById('leaderboard-list'); 
      if(!list) return; 
      list.innerHTML = ""; 
      const sortedIds = Object.keys(allScores).sort((a,b) => allScores[b].rings - allScores[a].rings);
      
      sortedIds.forEach((id, index) => {
          const s = allScores[id];
          const row = document.createElement('div'); 
          row.className = 'lb-row'; 
          const nameSpan = document.createElement('span'); 
          nameSpan.className = 'lb-name'; 
          if(id === socket.id) nameSpan.classList.add('lb-player');
          if(index === 0) nameSpan.classList.add('lb-rank-1');
          nameSpan.innerText = `${index+1}. ${s.name}`; 
          const scoreSpan = document.createElement('span'); 
          scoreSpan.className = 'lb-score'; 
          scoreSpan.innerText = `${s.rings}/${TOTAL_RINGS_WIN}`; 
          row.appendChild(nameSpan); 
          row.appendChild(scoreSpan); 
          list.appendChild(row); 
      });
  }
   
  // ✅ Fix 4: Consolidated ring collection Logic
  function ringCollected() { 
      if (typeof SFXManager !== 'undefined') SFXManager.playRing(isSfxEnabled());
      if (mp.roomId) {
          ringClaimLocked = true;
          // ✅ Fix 2 & 3: Send index based on ring object, not progress
          // ✅ Fix 5: Ensure currentRingObj is valid before finding index
          if (currentRingObj && rings) {
              const idx = rings.indexOf(currentRingObj);
              if (idx !== -1) {
                  // ✅ Fix 6: Send ringIndex for server validation
                  socket.emit('mp_claim_ring', { roomId: mp.roomId, ringIndex: idx });
              }
          }
          // Safety timeout in case score update is missed
          setTimeout(() => ringClaimLocked = false, 2000);
      }
  }

  // ✅ Fix 2: Safe Dispose Recursion (Corrected: using spread)
  function disposeHierarchy(obj) { 
      if (!obj) return; 
      if (obj.children) [...obj.children].forEach(disposeHierarchy); 
      if (obj.geometry) obj.geometry.dispose(); 
      if (obj.material) { 
          if (Array.isArray(obj.material)) obj.material.forEach(m => { if(m.map) m.map.dispose(); m.dispose(); }); 
          else { if(obj.material.map) obj.material.map.dispose(); obj.material.dispose(); } 
      } 
  }
   
  function initGame() {
    lockTouchScroll();
    const container = document.getElementById('game-container'); 
    // ✅ Fix 8: Show UI when game starts
    document.getElementById("ui-layer").style.display = "flex";
    
    if (scene) {
        bullets.forEach(b => {
            if (b && b.mesh) {
                // ✅ Fix 6: Clean up mesh but protect shared assets
                if (b.mesh.parent) b.mesh.parent.remove(b.mesh);
                b.mesh.userData = {}; 
            }
        });
        rings.forEach(r => disposeHierarchy(r));
        repairKits.forEach(k => disposeHierarchy(k));
        Object.values(otherPlayers).forEach(p => disposeHierarchy(p));
        if(terrainMesh) disposeHierarchy(terrainMesh);
        if(oceanMesh) disposeHierarchy(oceanMesh);
        // ✅ Fix: No scene.clear() to avoid light loss
    }
    bullets.length = 0; 
    rings = []; repairKits = []; bullets = []; ringWaypoints = [];
    
    if (renderer) {
      if(renderer.domElement && renderer.domElement.parentNode) renderer.domElement.parentNode.removeChild(renderer.domElement);
      renderer.dispose();
      // ✅ Fix 7: Manual disposal cleanup
      if(renderer.forceContextLoss) renderer.forceContextLoss();
      renderer.context = null;
      renderer.domElement = null;
    }

    scene = new THREE.Scene(); 
    scene.background = new THREE.Color(0x87CEEB); scene.fog = new THREE.Fog(0x87CEEB, 1500, 7000); 
    
    for (let pid in playersData) { 
        if(pid !== socket.id) addOtherPlayer(playersData[pid]); 
    }

    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 20000); 
    renderer = new THREE.WebGLRenderer({ antialias: true }); 
    renderer.setSize(window.innerWidth, window.innerHeight); 
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.25)); 
    renderer.shadowMap.enabled = false; 
    container.innerHTML = ""; container.appendChild(renderer.domElement);
    
    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6); scene.add(hemiLight); const dirLight = new THREE.DirectionalLight(0xffffff, 0.8); dirLight.position.set(100, 200, 50); 
    scene.add(dirLight);
    
    playerStats = { name: mp.playerName || "PLAYER", rings: 0, progress: 0 }; 
    if(allScores[socket.id]) allScores[socket.id].rings = 0;
    health = 100; boostLevel = 100;
    lastRender = performance.now();

    generateTerrain(); generateOcean(); createPlaneSystem(); createGuideArrow(); createRepairKits(); createRings(); updateRingVisuals(); updateLeaderboard(); isPlaying = true; isPaused = false; animate();
  }

  function fireBullet() {
      // ✅ Fix 1: Safety Check
      if (!planeRig || !scene) return;
      if (typeof SFXManager !== 'undefined') SFXManager.playGun(isSfxEnabled());
      const bullet = new THREE.Mesh(BULLET_GEO, BULLET_MAT_MY);
      bullet.position.copy(planeRig.position);
      bullet.quaternion.copy(planeRig.quaternion);
      bullet.translateZ(-10); 
      const velocity = new THREE.Vector3(0, 0, -BULLET_SPEED);
      velocity.applyQuaternion(planeRig.quaternion);
      bullet.userData = { velocity: velocity, life: 1.5, isMine: true }; 
      scene.add(bullet);
      bullets.push({ mesh: bullet });
      
      socket.emit('mp_player_fire', { 
          roomId: mp.roomId, 
          shooterId: socket.id,
          startPos: { x: bullet.position.x, y: bullet.position.y, z: bullet.position.z }, 
          quaternion: { x: bullet.quaternion.x, y: bullet.quaternion.y, z: bullet.quaternion.z, w: bullet.quaternion.w }
      });
  }

  function spawnNetworkBullet(startPos, quaternion, shooterId) {
      if (typeof SFXManager !== 'undefined') SFXManager.playGun(isSfxEnabled());
      const bullet = new THREE.Mesh(BULLET_GEO, BULLET_MAT_ENEMY);
      bullet.position.copy(startPos);
      bullet.quaternion.copy(quaternion);
      const velocity = new THREE.Vector3(0, 0, -BULLET_SPEED);
      velocity.applyQuaternion(quaternion);
      bullet.userData = { velocity: velocity, life: 1.5, isMine: false, shooterId: shooterId }; 
      scene.add(bullet);
      bullets.push({ mesh: bullet });
  }

  function respawnPlayer() {
      health = 100;
      if (typeof SFXManager !== 'undefined') SFXManager.playExplosion(isSfxEnabled());
      // ✅ Fix 13: Reset Rotation
      planeRig.position.y += 200;
      if (planeRig.position.y < 300) planeRig.position.y = 300;
      planeRig.rotation.set(0, planeRig.rotation.y, 0); 
      visualRoll = 0; 
      visualPitch = 0;
      const msg = document.getElementById("respawn-msg");
      msg.style.display = "block";
      setTimeout(() => msg.style.display = "none", 2000);
  }

  function getTerrainHeight(x, z) { let y = Math.sin(x * 0.001) * Math.cos(z * 0.001) * 1000 + Math.sin(x * 0.005) * 200; if (z > -1000 && z < 1000 && x > -1000 && x < 1000) y *= 0.1; if (y < -150) y = -150; return y - 50; }
   
  function generateTerrain() { 
      const geometry = new THREE.PlaneGeometry(50000, 50000, 120, 120); 
      geometry.rotateX(-Math.PI / 2); const positions = geometry.attributes.position; const colors = []; for (let i = 0; i < positions.count; i++) { const x = positions.getX(i); const z = positions.getZ(i); let y = Math.sin(x * 0.001) * Math.cos(z * 0.001) * 1000 + Math.sin(x * 0.005) * 200; if (z > -1000 && z < 1000 && x > -1000 && x < 1000) y *= 0.1; if (y < -150) y = -150; positions.setY(i, y); const color = new THREE.Color(); if (y < -50) color.setHex(TERRAIN_COLORS.SAND); else if (y < 100) color.setHex(TERRAIN_COLORS.SAND); else if (y < 500) color.setHex(TERRAIN_COLORS.GRASS); else if (y < 900) color.setHex(TERRAIN_COLORS.ROCK); else color.setHex(TERRAIN_COLORS.SNOW); colors.push(color.r, color.g, color.b); } geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3)); geometry.computeVertexNormals(); const mat = new THREE.MeshStandardMaterial({ vertexColors: true, roughness: 0.8, flatShading: true }); 
      terrainMesh = new THREE.Mesh(geometry, mat); 
      terrainMesh.position.y = -50; 
      scene.add(terrainMesh); 
  }
  function generateOcean() { 
      const geo = new THREE.PlaneGeometry(50000, 50000); geo.rotateX(-Math.PI / 2); const mat = new THREE.MeshBasicMaterial({ color: TERRAIN_COLORS.WATER, transparent: true, opacity: 0.6 }); 
      oceanMesh = new THREE.Mesh(geo, mat); 
      oceanMesh.position.y = -80; scene.add(oceanMesh); 
  }
  function createPlaneMesh(color) { const group = new THREE.Group(); const mat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.4 }); const glass = new THREE.MeshStandardMaterial({ color: 0x00aaff, opacity: 0.6, transparent: true }); const body = new THREE.Mesh(new THREE.CylinderGeometry(2, 4, 30, 8), mat); body.rotateX(-Math.PI/2); const nose = new THREE.Mesh(new THREE.ConeGeometry(2, 10, 8), mat); nose.rotateX(-Math.PI/2); nose.position.z = -20; const cockpit = new THREE.Mesh(new THREE.BoxGeometry(3, 3, 10), glass); cockpit.position.set(0, 2.5, -5); const lWing = new THREE.Mesh(new THREE.BoxGeometry(20, 0.5, 15), mat); lWing.position.set(-10, 0, 5); lWing.rotation.y = 0.3; const rWing = new THREE.Mesh(new THREE.BoxGeometry(20, 0.5, 15), mat); rWing.position.set(10, 0, 5); rWing.rotation.y = -0.3; const lTail = new THREE.Mesh(new THREE.BoxGeometry(8, 0.5, 8), mat); lTail.position.set(-5, 0, 18); lTail.rotation.y = 0.2; const rTail = new THREE.Mesh(new THREE.BoxGeometry(8, 0.5, 8), mat); rTail.position.set(5, 0, 18); rTail.rotation.y = -0.2; const lFin = new THREE.Mesh(new THREE.BoxGeometry(0.5, 8, 10), mat); lFin.position.set(-2, 4, 18); lFin.rotation.z = 0.2; const rFin = new THREE.Mesh(new THREE.BoxGeometry(0.5, 8, 10), mat); rFin.position.set(2, 4, 18); rFin.rotation.z = -0.2; const intakeGeo = new THREE.BoxGeometry(3, 4, 10); const lIntake = new THREE.Mesh(intakeGeo, mat); lIntake.position.set(-3.5, -1, 5); const rIntake = new THREE.Mesh(intakeGeo, mat); rIntake.position.set(3.5, -1, 5); group.add(body, nose, cockpit, lWing, rWing, lTail, rTail, lFin, rFin, lIntake, rIntake); return group; }
  function createPlaneSystem() { planeRig = new THREE.Group(); planeRig.position.set(0, 400, 800); scene.add(planeRig); planeMesh = createPlaneMesh(0x555555); planeRig.add(planeMesh); const glowGeo = new THREE.ConeGeometry(3, 10, 8); glowGeo.rotateX(Math.PI / 2); const glowMat = new THREE.MeshBasicMaterial({ color: 0x00d2ff, transparent: true, opacity: 0 }); const glow = new THREE.Mesh(glowGeo, glowMat); glow.position.set(0, 0, 20); glow.name = "EngineGlow"; planeMesh.add(glow); }
  function createGuideArrow() { const group = new THREE.Group(); const mat = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.8 }); const cylinder = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 15, 8), mat); cylinder.rotation.x = Math.PI / 2; cylinder.position.z = -7.5; const cone = new THREE.Mesh(new THREE.ConeGeometry(4, 8, 8), mat); cone.rotation.x = Math.PI / 2; group.add(cylinder, cone); guideArrow = group; scene.add(guideArrow); }
   
  function updateRingVisuals() { 
      const currentTargetIdx = playerStats.progress % RINGS_PER_LAP; 
      rings.forEach((r, i) => { 
          r.visible = (i === currentTargetIdx);
          if (i === currentTargetIdx) { 
              r.material.emissive.setHex(0xffaa00); 
              r.material.color.setHex(0xffd700); 
          } 
      }); 
      // ✅ Fix 5: Safe assignment after loop (Direct Access for reliability)
      currentRingObj = rings[currentTargetIdx] || null;
      // Note: We don't unlock here because server confirmation does that
  }
   
  function createRepairKits() { 
      const kitGroupPrototype = new THREE.Group(); 
      const boxGeo = new THREE.BoxGeometry(60, 60, 60); 
      const boxMat = new THREE.MeshPhongMaterial({ color: 0x00aa00, emissive: 0x003300, shininess: 30 }); 
      const box = new THREE.Mesh(boxGeo, boxMat); 
      kitGroupPrototype.add(box); 
      const crossMat = new THREE.MeshBasicMaterial({ color: 0xffffff }); 
      const vBar = new THREE.Mesh(new THREE.BoxGeometry(20, 70, 20), crossMat); 
      const hBar = new THREE.Mesh(new THREE.BoxGeometry(70, 20, 20), crossMat); 
      const dBar = new THREE.Mesh(new THREE.BoxGeometry(20, 20, 70), crossMat); 
      kitGroupPrototype.add(vBar, hBar, dBar); 
      const positions = [{ x: 1000, z: -3000 }, { x: -2000, z: -6000 }, { x: 500, z: -9000 }]; 
      
      positions.forEach((loc, index) => { 
          const groundY = getTerrainHeight(loc.x, loc.z); 
          const y = Math.max(300, groundY + 200); 
          const kit = kitGroupPrototype.clone(); 
          kit.position.set(loc.x, y, loc.z); 
          kit.userData = { active: true, respawnTime: 0, id: index }; 
          scene.add(kit); 
          repairKits.push(kit); 
      }); 
  }

  function drawMinimap() { if(!minimapCtx || !planeRig) return; minimapCtx.clearRect(0, 0, 140, 140); const cx = 70, cy = 70; const range = 4000; const scale = 60 / range; minimapCtx.save(); minimapCtx.translate(cx, cy); minimapCtx.rotate(-planeRig.rotation.y + Math.PI); minimapCtx.beginPath(); minimapCtx.moveTo(0, -6); minimapCtx.lineTo(-4, 4); minimapCtx.lineTo(4, 4); minimapCtx.fillStyle = "#00ff00"; minimapCtx.fill(); minimapCtx.restore(); function drawDot(obj, color, size) { if(!obj || !obj.visible) return; const dx = obj.position.x - planeRig.position.x; const dz = obj.position.z - planeRig.position.z; let px = dx * scale; let py = dz * scale; const dist = Math.sqrt(px*px + py*py); if (dist > 65) { const ratio = 65 / dist; px *= ratio; py *= ratio; } minimapCtx.beginPath(); minimapCtx.arc(cx + px, cy + py, size, 0, Math.PI * 2); minimapCtx.fillStyle = color; minimapCtx.fill(); } if(currentRingObj) drawDot(currentRingObj, "#ffd700", 4); Object.values(otherPlayers).forEach(p => drawDot(p, "#ff0000", 3)); }
   
  function animate() {
    if (!isPlaying || isPaused) return;

    // ✅ Fix 1: Safety Check
    if (!planeRig || !planeMesh) {
        requestAnimationFrame(animate);
        return;
    }

    const nowPerf = performance.now();
    if (nowPerf - lastRender < FRAME_TIME) {
        requestAnimationFrame(animate);
        return;
    }
    const dt = Math.min((nowPerf - lastRender) / 1000, 0.1);
    lastRender = nowPerf;

    frameCount++; 
    if (nowPerf - lastFrameTime >= 1000) { 
        if (fpsElem) fpsElem.innerText = "FPS: " + frameCount; 
        frameCount = 0; 
        lastFrameTime = nowPerf; 
    }
    const now = Date.now(); 
    
    if (isActionActive('fire') && now - lastFireTime > FIRE_RATE) { lastFireTime = now; fireBullet(); }

    for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        b.mesh.position.addScaledVector(b.mesh.userData.velocity, dt);
        b.mesh.userData.life -= dt; 

        if (b.mesh.userData.life <= 0) { 
            // ✅ Fix 6: Safe bullet disposal (browser compatible)
            if (b.mesh.parent) b.mesh.parent.remove(b.mesh);
            // ✅ Fix 3: Clear references without disposing shared geometry
            b.mesh.userData = {};
            bullets.splice(i, 1); 
            continue; 
        }
        
        if (!b.mesh.userData.isMine) {
            // ✅ Fix 5: Hit radius increased to 80 (6400 squared)
            if (planeRig && b.mesh.position.distanceToSquared(planeRig.position) < 6400) { 
                if (b.mesh.parent) b.mesh.parent.remove(b.mesh);
                bullets.splice(i, 1);
                health -= 10;
                if(health <= 0) respawnPlayer();
                continue;
            }
        }
    }

    let currentSpeed = NORMAL_SPEED; let isBoosting = false; 
    if (isActionActive('boost') && boostLevel > 0) { currentSpeed = BOOST_SPEED; isBoosting = true; boostLevel -= BOOST_DRAIN; if (boostLevel < 0) boostLevel = 0; } else { if (boostLevel < 100) boostLevel += BOOST_REFILL; } document.getElementById('boost-fill').style.width = boostLevel + '%';
    planeRig.translateZ(-currentSpeed);

    // Boundary Clamp for Local Player
    planeRig.position.x = THREE.MathUtils.clamp(planeRig.position.x, -WORLD_LIMIT, WORLD_LIMIT);
    planeRig.position.z = THREE.MathUtils.clamp(planeRig.position.z, -WORLD_LIMIT, WORLD_LIMIT);
    
    if (isActionActive('left')) { planeRig.rotation.y += TURN_SPEED; visualRoll = THREE.MathUtils.lerp(visualRoll, 0.8, 0.1); } else if (isActionActive('right')) { planeRig.rotation.y -= TURN_SPEED; visualRoll = THREE.MathUtils.lerp(visualRoll, -0.8, 0.1); } else visualRoll = THREE.MathUtils.lerp(visualRoll, 0, 0.1);
    if (isActionActive('up')) { planeRig.position.y += LIFT_SPEED; visualPitch = THREE.MathUtils.lerp(visualPitch, -0.5, 0.1); } else if (isActionActive('down')) { planeRig.position.y -= LIFT_SPEED; visualPitch = THREE.MathUtils.lerp(visualPitch, 0.5, 0.1); } else visualPitch = THREE.MathUtils.lerp(visualPitch, 0, 0.1);
    
    const groundHeight = getTerrainHeight(planeRig.position.x, planeRig.position.z); let isDamaging = false; 
    if (planeRig.position.y < groundHeight + 15) { 
        planeRig.position.y = groundHeight + 15;
        if (now - lastCrashTime > 500) {
            health -= COLLISION_DAMAGE; 
            isDamaging = true; 
            lastCrashTime = now;
            if (health <= 0) { respawnPlayer(); } 
        }
    }
    
    // ✅ Fix 8: GameManager/SFX Safety
    if (typeof SFXManager !== 'undefined' && SFXManager.updateContinuous) {
        SFXManager.updateContinuous(isBoosting, isDamaging, isSfxEnabled());
    }
    if (typeof MusicManager !== 'undefined' && MusicManager.updateGameplayMusic) {
        MusicManager.updateGameplayMusic(health);
    }
    document.getElementById('health-fill').style.width = health + '%';
    
    if (currentRingObj) { 
        guideArrow.visible = true; 
        guideArrow.position.copy(planeRig.position); 
        guideArrow.position.y += 60; 
        guideArrow.lookAt(currentRingObj.position); 
        
        if (planeRig.position.distanceTo(currentRingObj.position) < 100) { 
            // ✅ Fix 4: Consolidated Ring Claim Logic
            if (!ringClaimLocked) {
                ringCollected();
            }
        } 
    } else {
        guideArrow.visible = false;
    }
    
    repairKits.forEach(kit => { 
        // ✅ Fix 6: Reliable active check
        if (kit.userData.active && kit.visible && planeRig.position.distanceTo(kit.position) < 80) { 
            if (!kit.userData.lastClaimTs) kit.userData.lastClaimTs = 0;
            if (now - kit.userData.lastClaimTs > 1000) {
                kit.userData.lastClaimTs = now;
                if (mp.roomId) {
                    socket.emit('mp_claim_kit', { roomId: mp.roomId, kitIndex: kit.userData.id });
                }
            }
        } 
        
        // ✅ Fix 7: Local respawn timer fallback
        if(!kit.userData.active && kit.userData.respawnTime && now > kit.userData.respawnTime){
            kit.visible = true;
            kit.userData.active = true;
            kit.userData.respawnTime = 0;
        }
    });
    
    rings.forEach(r => r.rotation.z += 0.01); drawMinimap();
    
    if (socket && mp.roomId && (now - lastNetworkTick > NETWORK_TICK_RATE)) { 
        const q = planeRig.quaternion; 
        // ✅ Fix 10: Timestamp
        socket.emit("playerMovement", { roomId: mp.roomId, x: planeRig.position.x, y: planeRig.position.y, z: planeRig.position.z, rotX: visualPitch, rotZ: visualRoll, quaternion: { x: q.x, y: q.y, z: q.z, w: q.w }, ts: Date.now() }); 
        lastNetworkTick = now;
    }

    const renderTimestamp = now - 100; 
    Object.values(otherPlayers).forEach(p => {
        const buffer = p.userData.buffer;
        if (buffer && buffer.length >= 2) {
            let t1 = buffer[0], t2 = buffer[1];
            let i = 0;
            while (i < buffer.length - 1 && buffer[i+1].time <= renderTimestamp) {
                t1 = buffer[i]; 
                t2 = buffer[i+1];
                i++;
            }
            
            if (t2.time >= renderTimestamp) {
               const alpha = (renderTimestamp - t1.time) / (t2.time - t1.time);
               // Interpolate RIG
               p.position.lerpVectors(t1.pos, t2.pos, alpha);
               p.quaternion.slerpQuaternions(t1.quat, t2.quat, alpha);
               
               // ✅ Fix 11: Interpolate VISUAL MESH (Child) else block handled below
               if(p.children[0]) {
                   p.children[0].rotation.z = THREE.MathUtils.lerp(t1.roll, t2.roll, alpha);
                   p.children[0].rotation.x = THREE.MathUtils.lerp(t1.pitch, t2.pitch, alpha);
               }
            } else {
               p.position.copy(t2.pos);
               p.quaternion.copy(t2.quat);
               // ✅ Fix 11: Snap rotation on latest packet
               if(p.children[0]) {
                   p.children[0].rotation.z = t2.roll;
                   p.children[0].rotation.x = t2.pitch;
               }
            }
            
            // Boundary Clamp for Other Players
            p.position.x = THREE.MathUtils.clamp(p.position.x, -WORLD_LIMIT, WORLD_LIMIT);
            p.position.z = THREE.MathUtils.clamp(p.position.z, -WORLD_LIMIT, WORLD_LIMIT);
        }
    });

    planeMesh.rotation.z = visualRoll; planeMesh.rotation.x = visualPitch; const targetCamPos = new THREE.Vector3(0, 100, 300).applyMatrix4(planeRig.matrixWorld); camera.position.lerp(targetCamPos, 0.1); camera.lookAt(planeRig.position);
    renderer.render(scene, camera); requestAnimationFrame(animate);
  }

  function endGame(win, reason) { 
    isPlaying = false; 
    // ✅ Fix 4: Hide UI on End Game
    document.getElementById("ui-layer").style.display = "none";
    if (typeof MusicManager !== 'undefined') MusicManager.stop();
    if (typeof SFXManager !== 'undefined' && SFXManager.updateContinuous) {
        SFXManager.updateContinuous(false, false, false); 
        SFXManager.stopAll(); 
    }
    // ✅ Fix 1: Corrected syntax for music
    if(win) {
        if (typeof MusicManager !== 'undefined') MusicManager.playWin();
    } else {
        if (typeof MusicManager !== 'undefined') MusicManager.playLose();
    }
    // ✅ Fix 17: Leave room on end
    if(mp.roomId) socket.emit("mp_leave_room", { roomId: mp.roomId });
    
    const screen = document.getElementById('end-screen'); const title = document.getElementById('end-title'); const msg = document.getElementById('end-msg'); 
    if (win) { title.innerText = "VICTORY"; title.className = "win-text"; msg.innerText = reason || "Race Champion!"; } else { title.innerText = "DEFEAT"; title.className = "lose-text"; msg.innerText = reason || "Lost"; } 
    screen.classList.remove('hidden'); 
  }
  window.addEventListener('resize', () => { if (camera && renderer) { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); } });
</script>
</body>
</html>
