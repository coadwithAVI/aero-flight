<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Sky Pilot - Multiplayer</title>

  <!-- Socket.IO client -->
  <script src="https://cdn.socket.io/4.7.4/socket.io.min.js"></script>
  <!-- THREE.JS LIBRARY -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  
  <!-- Config, Map aur Managers -->
  <script src="game-config.js"></script>
  <script src="map.js"></script>
  <script src="game-manager.js"></script>
  <script src="sfx-manager.js"></script>
  <script src="music-manager.js"></script>

  <style>
    body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; user-select: none; touch-action: none; }
    #game-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }

    #ui-layer {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      pointer-events: none;
      display: none; 
      flex-direction: column; justify-content: space-between;
      padding: 20px; box-sizing: border-box;
      z-index: 5;
    }

    .hud-top { display: flex; justify-content: space-between; align-items: flex-start; }
    .left-hud { display: flex; flex-direction: column; align-items: flex-start; gap: 15px; }
    .right-hud { display: flex; flex-direction: column; align-items: flex-end; gap: 10px; pointer-events: auto; }

    .leaderboard-box {
      background: rgba(0,0,0,0.6); padding: 15px; border-radius: 10px;
      color: white; min-width: 220px; backdrop-filter: blur(4px); border-left: 5px solid #ffd700;
    }
    .lb-title { font-weight: 900; font-size: 14px; color: #ffd700; border-bottom: 1px solid #555; padding-bottom: 5px; margin-bottom: 8px; letter-spacing: 1px; }
    .lb-row { display: flex; justify-content: space-between; font-size: 14px; margin-bottom: 4px; font-weight: bold; }
    .lb-name { color: #ddd; }
    .lb-player { color: #00ff00; text-shadow: 0 0 5px #00ff00; }
    .lb-rank-1 { color: #ffd700; }

    .bar-container { width: 220px; text-align: left; }
    .bar-bg { width: 100%; height: 12px; background: rgba(0,0,0,0.6); border: 1px solid #444; border-radius: 6px; overflow: hidden; transform: skewX(-20deg); }
    #health-fill { width: 100%; height: 100%; background: linear-gradient(90deg, #cc0000, #00ff00); transition: width 0.1s linear; }
    #boost-fill { width: 100%; height: 100%; background: linear-gradient(90deg, #0066ff, #00d2ff); transition: width 0.1s linear; }

    #fps-counter { background: rgba(0,0,0,0.5); color: #00ff00; padding: 5px 10px; border-radius: 5px; font-family: monospace; font-size: 12px; margin-bottom: 5px; }
    .pause-btn { background: rgba(0,0,0,0.6); color: white; border: 2px solid white; width: 40px; height: 40px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; cursor: pointer; transition: 0.2s; }
    .pause-btn:hover { background: white; color: black; }

    #minimap-container { position: absolute; bottom: 20px; left: 20px; width: 140px; height: 140px; background: rgba(0,10,30,0.8); border: 2px solid #00d2ff; border-radius: 50%; overflow: hidden; box-shadow: 0 0 15px rgba(0,210,255,0.3); }
    #minimap-canvas { width: 100%; height: 100%; }

    .mobile-controls { display: none; position: absolute; bottom: 20px; width: 100%; padding: 0 20px; box-sizing: border-box; justify-content: space-between; pointer-events: none; }
    @media (max-width: 1024px) { .mobile-controls { display: flex; } }
    .control-group { pointer-events: auto; display: flex; gap: 10px; }
    .dpad { display: grid; grid-template-columns: 60px 60px 60px; grid-template-rows: 60px 60px; gap: 5px; }
    .mob-btn { width: 60px; height: 60px; background: rgba(255,255,255,0.1); border: 2px solid rgba(255,255,255,0.3); border-radius: 50%; color: white; font-weight: bold; display: flex; align-items: center; justify-content: center; user-select: none; backdrop-filter: blur(4px); }
    .mob-btn:active { background: rgba(0, 210, 255, 0.4); }
    .mob-btn-rect { width: 80px; height: 60px; border-radius: 15px; font-size: 14px; }
    .btn-up { grid-column: 2; grid-row: 1; } .btn-left { grid-column: 1; grid-row: 2; } .btn-down { grid-column: 2; grid-row: 2; } .btn-right { grid-column: 3; grid-row: 2; }

    .screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); backdrop-filter: blur(10px); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 100; }
    .hidden { display: none !important; }
    .menu-box { background: rgba(15,25,35,0.95); border: 2px solid #00d2ff; border-radius: 20px; padding: 40px; text-align: center; width: 480px; box-shadow: 0 0 30px rgba(0,210,255,0.2); }
    .action-btn { display: block; width: 100%; padding: 18px; margin: 15px 0; background: linear-gradient(135deg, #00d2ff, #0077ff); border: none; color: white; border-radius: 40px; font-weight: 900; font-size: 18px; cursor: pointer; text-transform: uppercase; letter-spacing: 1px; transition: 0.2s; }
    .action-btn:hover { transform: scale(1.02); filter: brightness(1.1); }
    .secondary-btn { background: rgba(255,255,255,0.05); border: 1px solid #555; }

    input { margin-top: 10px; padding: 15px; width: 85%; border-radius: 10px; border: none; background: rgba(255,255,255,0.1); color: #fff; font-size: 18px; font-weight: bold; text-align: center; outline: none; border: 1px solid #444; }
    input:focus { border-color: #00d2ff; background: rgba(255,255,255,0.15); }
    
    #respawn-msg { position: absolute; top: 35%; width: 100%; text-align: center; color: #ff4444; font-size: 45px; font-weight: 900; text-shadow: 0 0 20px black; display: none; pointer-events: none; }
    .win-text { color: #00ff00; text-shadow: 0 0 20px #00ff00; }
    .lose-text { color: #ff4444; text-shadow: 0 0 20px #ff4444; }
  </style>
</head>
<body>

  <div id="game-container"></div>
  <div id="respawn-msg">CRITICAL DAMAGE - REBOOTING SYSTEM</div>

  <!-- HUD Overlay -->
  <div id="ui-layer">
    <div class="hud-top">
      <div class="left-hud">
        <div id="fps-counter">FPS: 0</div>
        <div class="bar-container">
          <div style="color:#00ff00; font-size:12px; margin-bottom:5px; font-weight:bold;">HULL INTEGRITY</div>
          <div class="bar-bg"><div id="health-fill"></div></div>
        </div>
        <div class="leaderboard-box">
          <div class="lb-title">RACE STANDINGS</div>
          <div id="leaderboard-list"></div>
        </div>
      </div>
      <div class="right-hud">
        <div style="display:flex; gap:20px; align-items:flex-start;">
          <div class="bar-container">
            <div style="color:#00d2ff; font-size:12px; margin-bottom:5px; text-align:right; font-weight:bold;">THRUST BOOST</div>
            <div class="bar-bg"><div id="boost-fill"></div></div>
          </div>
          <div class="pause-btn" onclick="togglePause()">||</div>
        </div>
      </div>
    </div>
    
    <div id="minimap-container"><canvas id="minimap-canvas" width="140" height="140"></canvas></div>
    
    <!-- Mobile Input -->
    <div class="mobile-controls">
        <div class="control-group dpad">
            <div class="mob-btn btn-up" ontouchstart="setKey('up', true)" ontouchend="setKey('up', false)" ontouchcancel="setKey('up', false)">▲</div>
            <div class="mob-btn btn-left" ontouchstart="setKey('left', true)" ontouchend="setKey('left', false)" ontouchcancel="setKey('left', false)">◀</div>
            <div class="mob-btn btn-down" ontouchstart="setKey('down', true)" ontouchend="setKey('down', false)" ontouchcancel="setKey('down', false)">▼</div>
            <div class="mob-btn btn-right" ontouchstart="setKey('right', true)" ontouchend="setKey('right', false)" ontouchcancel="setKey('right', false)">▶</div>
        </div>
        <div class="control-group" style="flex-direction: column; justify-content: flex-end;">
            <div class="mob-btn mob-btn-rect" style="border-color:#ff4444; color:#ff4444;" ontouchstart="setKey('fire', true)" ontouchend="setKey('fire', false)" ontouchcancel="setKey('fire', false)">FIRE</div>
            <div class="mob-btn mob-btn-rect" style="border-color:#00d2ff; color:#00d2ff;" ontouchstart="setKey('boost', true)" ontouchend="setKey('boost', false)" ontouchcancel="setKey('boost', false)">BOOST</div>
        </div>
    </div>
  </div>

  <!-- Multiplayer Menu -->
  <div id="mp-menu-screen" class="screen">
    <div class="menu-box">
      <h1 style="color:white; font-size:45px; margin-bottom:10px; font-style:italic;">SKY PILOT</h1>
      <h2 style="color:#00d2ff; font-size:18px; margin-bottom:30px; letter-spacing:2px;">MULTIPLAYER MODE</h2>
      <button class="action-btn" onclick="mpCreateRoom()">CREATE PRIVATE ROOM</button>
      <div style="margin: 10px 0; color:#555;">— OR —</div>
      <input id="mp-room-code" placeholder="ENTER 4-LETTER CODE" maxlength="4" />
      <button class="action-btn secondary-btn" onclick="mpJoinRoom()">JOIN MISSION</button>
      <button class="action-btn secondary-btn" style="color:#888;" onclick="window.location.href='index.html'">BACK TO BASE</button>
    </div>
  </div>

  <!-- Lobby -->
  <div id="lobby-screen" class="screen hidden">
    <div class="menu-box">
      <h1 style="color:white; font-size:32px;">LOBBY HANGAR</h1>
      <p style="color:#00d2ff; font-weight:800; font-size:20px; margin: 15px 0;">ROOM CODE: <span id="lobby-room-id" style="color:white; letter-spacing:3px;">----</span></p>
      <div style="background:rgba(0,0,0,0.3); padding:20px; border-radius:10px; margin-bottom:20px;">
          <div style="color:#888; font-size:12px; text-align:left; margin-bottom:10px; font-weight:bold;">PILOTS READY:</div>
          <div id="lobby-player-list" style="color:#ddd; text-align:left; font-family:monospace; line-height:1.6;"></div>
      </div>
      <button id="host-start-btn" class="action-btn hidden" onclick="mpHostStartGame()">LAUNCH SQUADRON</button>
      <button class="action-btn secondary-btn" onclick="mpLeaveLobby()">ABORT LOBBY</button>
    </div>
  </div>

  <!-- Countdown -->
  <div id="countdown-screen" class="screen hidden">
    <div class="menu-box" style="border:none; background:none; box-shadow:none;">
      <h1 id="countdown-text" style="font-size:150px; color:white; text-shadow: 0 0 40px #00d2ff;">3</h1>
      <p style="color:#00d2ff; font-weight:900; font-size:24px; letter-spacing:5px;">ENGAGING ENGINES</p>
    </div>
  </div>

  <!-- End Game -->
  <div id="end-screen" class="screen hidden">
    <div class="menu-box">
      <h1 id="end-title" style="font-size:55px;">VICTORY</h1>
      <p id="end-msg" style="color:white; font-size:20px; margin-bottom:30px;">Winner Name</p>
      <button class="action-btn" onclick="location.reload()">RETURN TO MENU</button>
    </div>
  </div>

<script>
  // --- KONFIGURASI ---
  // ✅ FIX: Rings count server se sync rakhne ke liye 8 kiya hai
  const Cfg = window.SKY_CONFIG || {
      RINGS_PER_LAP: 8, 
      TOTAL_RINGS_WIN: 8, 
      NORMAL_SPEED: 5, BOOST_SPEED: 10,
      TURN_SPEED: 0.03, LIFT_SPEED: 5, FIRE_RATE: 120, COLLISION_DAMAGE: 8,
      BOOST_DRAIN: 0.5, BOOST_REFILL: 0.1, 
      BULLET_SPEED: 4000, 
      TERRAIN_COLORS: { SAND: 0xeebb88, GRASS: 0x55aa55, ROCK: 0x666666, SNOW: 0xffffff, WATER: 0x004488 }
  };

  // --- NETWORK STATE ---
  let socket;
  if (typeof io !== "undefined") {
      socket = io(window.location.origin, { transports: ["websocket"] });
  } else {
      socket = { emit() {}, on() {}, off() {} };
  }

  let mp = { roomId: null, isHost: false, inLobby: false, playerName: null };
  const otherPlayers = {}; const playersData = {}; const allScores = {};
  let lastNetworkTick = 0; const NETWORK_TICK_RATE = 50;
  let ringClaimLocked = false;
  let gameSeed = 12345;

  // Visual Assets
  const BULLET_GEO = new THREE.SphereGeometry(2, 8, 8);
  const BULLET_MAT_MY = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
  const BULLET_MAT_ENEMY = new THREE.MeshBasicMaterial({ color: 0xff0000 });

  // Game Engine Vars
  let scene, camera, renderer, planeRig, planeMesh, guideArrow;
  let terrainMesh, oceanMesh, rings = [], ringWaypoints = [], currentRingObj = null, repairKits = [], bullets = [];
  let isPlaying = false, isPaused = false;
  let boostLevel = 100, health = 100, lastFireTime = 0, lastCrashTime = 0;
  const activeKeys = {}; let visualRoll = 0, visualPitch = 0;
  let playerStats = { name: "PLAYER", rings: 0, progress: 0 };
  let lastFrameTime = performance.now(), frameCount = 0, miniTick = 0;

  const fpsElem = document.getElementById('fps-counter');
  const minimapCtx = document.getElementById('minimap-canvas').getContext('2d');

  // --- UI & SCREEN HELPERS ---
  function showScreen(id) { 
      document.querySelectorAll(".screen").forEach(s => s.classList.add("hidden")); 
      const el = document.getElementById(id); 
      if (el) el.classList.remove("hidden"); 
  }
  
  function lobbyRenderPlayers(players) { 
      const list = document.getElementById("lobby-player-list"); 
      list.innerHTML = ""; 
      players.forEach((p, i) => { 
          const row = document.createElement("div"); 
          row.style.marginBottom = "5px";
          row.textContent = `${i+1}. ${p.name}${p.isHost ? " (COMMANDER)" : " (WINGMAN)"}`; 
          list.appendChild(row); 
      }); 
  }

  function isSfxEnabled() { return (window.GameManager && window.GameManager.data) ? !!window.GameManager.data.sfx : true; }
  
  // --- MULTIPLAYER ACTION FUNCTIONS ---
  window.mpCreateRoom = function() {
      if (typeof SFXManager !== 'undefined') SFXManager.init();
      mp.playerName = (prompt("Apna callsign batayein:", "VIPER") || "").trim() || "PILOT";
      socket.emit("mp_create_room", { name: mp.playerName });
  }

  window.mpJoinRoom = function() {
      if (typeof SFXManager !== 'undefined') SFXManager.init();
      mp.playerName = (prompt("Apna callsign batayein:", "ACE") || "").trim() || "PILOT";
      const room = (document.getElementById("mp-room-code").value || "").trim().toUpperCase();
      if (!room) return alert("Hangar code enter karein!");
      socket.emit("mp_join_room", { roomId: room, name: mp.playerName });
  }

  window.mpLeaveLobby = function() {
      socket.emit("mp_leave_room", { roomId: mp.roomId });
      location.reload();
  }

  window.mpHostStartGame = function() {
      if (!mp.isHost) return;
      socket.emit("mp_start_game", { roomId: mp.roomId, seed: Math.floor(Math.random() * 100000) });
  }

  // --- SOCKET LISTENERS ---
  socket.on("mp_room_created", ({ roomId, players }) => { 
      mp.roomId = roomId; mp.isHost = true; mp.inLobby = true; 
      document.getElementById("lobby-room-id").innerText = roomId; 
      lobbyRenderPlayers(players); 
      document.getElementById("host-start-btn").classList.remove("hidden"); 
      showScreen("lobby-screen"); 
  });

  socket.on("mp_room_joined", ({ roomId, players, hostId }) => { 
      mp.roomId = roomId; mp.isHost = (socket.id === hostId); mp.inLobby = true; 
      document.getElementById("lobby-room-id").innerText = roomId; 
      lobbyRenderPlayers(players); 
      showScreen("lobby-screen"); 
  });

  socket.on("mp_lobby_update", ({ players, hostId }) => { 
      mp.isHost = (socket.id === hostId); 
      lobbyRenderPlayers(players); 
      document.getElementById("host-start-btn").classList.toggle("hidden", !mp.isHost); 
  });

  socket.on("mp_game_starting", (data) => { 
      if(data && data.seed !== undefined) gameSeed = data.seed; 
      showScreen("countdown-screen"); 
      mpCountdownThenStart(); 
  });

  socket.on("currentPlayers", (players) => { 
      Object.keys(players).forEach(id => { 
          if (id !== socket.id) addOtherPlayer(players[id]); 
          allScores[id] = { name: players[id].name, rings: 0 }; 
      }); 
      allScores[socket.id] = { name: mp.playerName, rings: 0 }; 
  });

  socket.on("newPlayer", (info) => { 
      addOtherPlayer(info); 
      allScores[info.playerId] = { name: info.name, rings: 0 }; 
      updateLeaderboard(); 
  });

  socket.on("playerDisconnected", (id) => { 
      removeOtherPlayer(id); 
      delete allScores[id]; 
      updateLeaderboard(); 
  });

  socket.on("playerMoved", (info) => { 
      const p = otherPlayers[info.playerId]; 
      if (!p) return;
      const snapshot = { 
          time: info.ts || Date.now(), 
          pos: new THREE.Vector3(info.x, info.y, info.z), 
          quat: new THREE.Quaternion(info.quaternion.x, info.quaternion.y, info.quaternion.z, info.quaternion.w), 
          roll: info.rotZ || 0, pitch: info.rotX || 0 
      };
      if (!p.userData.buffer) p.userData.buffer = []; 
      p.userData.buffer.push(snapshot);
      if (p.userData.buffer.length > 8) p.userData.buffer.shift();
  });

  socket.on("mp_score_update", ({ playerId, rings, nextRingIndex }) => {
      if (allScores[playerId]) {
          allScores[playerId].rings = rings; updateLeaderboard();
          if (playerId === socket.id) { 
              ringClaimLocked = false; 
              playerStats.rings = rings; 
              playerStats.progress = nextRingIndex !== undefined ? nextRingIndex : rings; 
              updateRingVisuals(); 
              if (typeof SFXManager !== 'undefined') SFXManager.playRing(isSfxEnabled()); 
          }
      }
  });

  // ✅ RESYNC Logic: Agar server mana kar de, toh client ko forcibly sync karein
  socket.on("mp_ring_reject", ({ expectedIndex }) => { 
      console.warn("Ring sync error. Re-aligning to index:", expectedIndex); 
      ringClaimLocked = false; 
      if (typeof expectedIndex === "number") { 
          playerStats.progress = expectedIndex; 
          updateRingVisuals(); 
      } 
  });
  
  socket.on("mp_player_fire", (data) => { 
      if (data.shooterId === socket.id) return; 
      spawnNetworkBullet(
          new THREE.Vector3(data.startPos.x, data.startPos.y, data.startPos.z), 
          new THREE.Quaternion(data.quaternion.x, data.quaternion.y, data.quaternion.z, data.quaternion.w)
      ); 
  });

  socket.on("mp_game_over", ({ winnerName, winnerId }) => endGame(winnerId === socket.id, winnerName));

  function mpCountdownThenStart() { 
      let n = 3; 
      const txt = document.getElementById("countdown-text"); 
      txt.innerText = n; 
      const timer = setInterval(() => { 
          n--; 
          if (n > 0) txt.innerText = n; 
          else if (n === 0) { txt.innerText = "GO!"; }
          else { clearInterval(timer); initGame(); } 
      }, 1000); 
  }

  // --- ENGINE LOGIC ---
  function initGame() {
      document.getElementById("ui-layer").style.display = "flex";
      showScreen(""); 

      const container = document.getElementById('game-container');
      if (renderer) {
          renderer.dispose();
          if(renderer.domElement.parentNode) renderer.domElement.parentNode.removeChild(renderer.domElement);
      }

      scene = new THREE.Scene(); 
      scene.background = new THREE.Color(0x87CEEB); 
      scene.fog = new THREE.Fog(0x87CEEB, 2000, 15000); 
      
      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 15000);
      renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
      renderer.setSize(window.innerWidth, window.innerHeight); 
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1));
      container.appendChild(renderer.domElement);

      scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 0.6));
      const dl = new THREE.DirectionalLight(0xffffff, 0.8); dl.position.set(100, 200, 50); scene.add(dl);

      // ✅ Integration: Shared Map Logic
      terrainMesh = MapManager.generateTerrain(Cfg); scene.add(terrainMesh);
      oceanMesh = MapManager.generateOcean(Cfg); scene.add(oceanMesh);
      const ringData = MapManager.generateRings(Cfg.RINGS_PER_LAP, gameSeed); 
      rings = ringData.rings; ringWaypoints = ringData.waypoints;
      rings.forEach(r => scene.add(r));

      createPlaneSystem(); 
      createGuideArrow(); 
      updateRingVisuals(); 
      updateLeaderboard();
      
      isPlaying = true; isPaused = false; 
      animate();
  }

  // Naya detailed Airplane Mesh (Detailed parts ke saath)
  function createPlaneMesh(color) {
      const g = new THREE.Group(); 
      const mat = new THREE.MeshStandardMaterial({ color, roughness: 0.4 });
      const glass = new THREE.MeshStandardMaterial({ color: 0x00aaff, opacity: 0.6, transparent: true });

      // Body Parts
      const body = new THREE.Mesh(new THREE.CylinderGeometry(2, 4, 30, 8), mat); body.rotateX(-Math.PI/2);
      const nose = new THREE.Mesh(new THREE.ConeGeometry(2, 10, 8), mat); nose.rotateX(-Math.PI/2); nose.position.z = -20;
      const cockpit = new THREE.Mesh(new THREE.BoxGeometry(3, 3, 10), glass); cockpit.position.set(0, 2.5, -5);
      
      // Wings & Stabilizers
      const wings = new THREE.Mesh(new THREE.BoxGeometry(20, 0.5, 10), mat); wings.position.set(0, 0, 5);
      const lTail = new THREE.Mesh(new THREE.BoxGeometry(8, 0.5, 6), mat); lTail.position.set(-5, 0, 18);
      const rTail = new THREE.Mesh(new THREE.BoxGeometry(8, 0.5, 6), mat); rTail.position.set(5, 0, 18);
      const fin = new THREE.Mesh(new THREE.BoxGeometry(0.5, 8, 8), mat); fin.position.set(0, 4, 18);

      g.add(body, nose, cockpit, wings, lTail, rTail, fin); 
      return g;
  }

  function createPlaneSystem() { 
      planeRig = new THREE.Group(); 
      planeRig.position.set(0, 400, 800); 
      scene.add(planeRig); 
      planeMesh = createPlaneMesh(0x555555); 
      planeRig.add(planeMesh); 
      
      const glow = new THREE.Mesh(
          new THREE.ConeGeometry(3, 10, 8), 
          new THREE.MeshBasicMaterial({ color: 0x00d2ff, transparent: true, opacity: 0 })
      );
      glow.rotateX(Math.PI/2); glow.position.z = 20; glow.name = "EngineGlow"; 
      planeMesh.add(glow); 
  }

  function addOtherPlayer(info) {
      if (otherPlayers[info.playerId]) return;
      const rig = new THREE.Group(); 
      rig.add(createPlaneMesh(0xff0000)); 
      rig.position.set(info.x, info.y, info.z);
      scene.add(rig); otherPlayers[info.playerId] = rig;
  }

  function removeOtherPlayer(id) { if (otherPlayers[id]) { scene.remove(otherPlayers[id]); disposeHierarchy(otherPlayers[id]); delete otherPlayers[id]; } }

  function spawnBullet() {
      const bullet = new THREE.Mesh(BULLET_GEO, BULLET_MAT_MY); 
      bullet.position.copy(planeRig.position); bullet.quaternion.copy(planeRig.quaternion);
      const v = new THREE.Vector3(0,0,-1).applyQuaternion(planeRig.quaternion).multiplyScalar(Cfg.BULLET_SPEED);
      bullets.push({ mesh: bullet, velocity: v, life: 1.5, isMine: true }); 
      scene.add(bullet);
      
      socket.emit('mp_player_fire', { 
          roomId: mp.roomId, shooterId: socket.id, 
          startPos: planeRig.position, quaternion: planeRig.quaternion 
      });
      if (typeof SFXManager !== 'undefined') SFXManager.playGun(isSfxEnabled());
  }

  function spawnNetworkBullet(pos, quat) {
      const bullet = new THREE.Mesh(BULLET_GEO, BULLET_MAT_ENEMY); 
      bullet.position.copy(pos); bullet.quaternion.copy(quat);
      const v = new THREE.Vector3(0,0,-1).applyQuaternion(quat).multiplyScalar(Cfg.BULLET_SPEED);
      bullets.push({ mesh: bullet, velocity: v, life: 1.5, isMine: false }); 
      scene.add(bullet);
      if (typeof SFXManager !== 'undefined') SFXManager.playGun(isSfxEnabled());
  }

  function updateRingVisuals() { 
      const curr = playerStats.progress % Cfg.RINGS_PER_LAP; 
      rings.forEach((r, i) => { 
          r.visible = (i === curr); 
          if(i === curr) { r.material.emissive.setHex(0xffaa00); currentRingObj = r; } 
      }); 
  }

  function createGuideArrow() { 
      guideArrow = new THREE.Group(); 
      guideArrow.add(new THREE.Mesh(new THREE.ConeGeometry(4, 10, 8), new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent:true, opacity:0.8 }))); 
      guideArrow.children[0].rotateX(Math.PI/2); 
      scene.add(guideArrow); 
  }

  function animate() {
      if (!isPlaying || isPaused) return;
      const dt = 1/60; const now = Date.now();

      // Bullets processing
      for(let i=bullets.length-1; i>=0; i--) {
          const b = bullets[i]; 
          b.mesh.position.addScaledVector(b.velocity, dt); b.life -= dt;
          if (b.life <= 0) { if(b.mesh.parent) b.mesh.parent.remove(b.mesh); bullets.splice(i, 1); continue; }
          // Collision logic for bullets
          if (!b.isMine && b.mesh.position.distanceTo(planeRig.position) < 80) { 
              health -= 10; 
              if(b.mesh.parent) b.mesh.parent.remove(b.mesh); 
              bullets.splice(i, 1); 
              if(health <= 0) respawnPlayer();
              continue; 
          }
      }

      // Movement logic
      let spd = isActionActive('boost') && boostLevel > 0 ? Cfg.BOOST_SPEED : Cfg.NORMAL_SPEED;
      if(isActionActive('boost') && boostLevel > 0) { 
          boostLevel -= Cfg.BOOST_DRAIN; 
          planeMesh.getObjectByName("EngineGlow").material.opacity = 0.8; 
      } else { 
          boostLevel = Math.min(100, boostLevel + Cfg.BOOST_REFILL); 
          planeMesh.getObjectByName("EngineGlow").material.opacity = 0; 
      }
      planeRig.translateZ(-spd);
      
      // Control turns
      if(isActionActive('left')) { planeRig.rotation.y += Cfg.TURN_SPEED; visualRoll = THREE.MathUtils.lerp(visualRoll, 0.8, 0.1); }
      else if(isActionActive('right')) { planeRig.rotation.y -= Cfg.TURN_SPEED; visualRoll = THREE.MathUtils.lerp(visualRoll, -0.8, 0.1); }
      else visualRoll = THREE.MathUtils.lerp(visualRoll, 0, 0.1);
      
      if(isActionActive('up')) { planeRig.position.y += Cfg.LIFT_SPEED; visualPitch = THREE.MathUtils.lerp(visualPitch, -0.4, 0.1); }
      else if(isActionActive('down')) { planeRig.position.y -= Cfg.LIFT_SPEED; visualPitch = THREE.MathUtils.lerp(visualPitch, 0.4, 0.1); }
      else visualPitch = THREE.MathUtils.lerp(visualPitch, 0, 0.1);

      // Boundary & Ground
      const h = MapManager.getTerrainHeight(planeRig.position.x, planeRig.position.z);
      if(planeRig.position.y < h + 20) { 
          planeRig.position.y = h + 20; 
          if(now - lastCrashTime > 500) { 
              health -= Cfg.COLLISION_DAMAGE; 
              lastCrashTime = now; 
              if(health <= 0) respawnPlayer();
          } 
      }

      // UI update
      document.getElementById('health-fill').style.width = health + '%';
      document.getElementById('boost-fill').style.width = boostLevel + '%';
      planeMesh.rotation.z = visualRoll; planeMesh.rotation.x = visualPitch;
      const ct = new THREE.Vector3(0, 100, 300).applyMatrix4(planeRig.matrixWorld); 
      camera.position.lerp(ct, 0.1); 
      camera.lookAt(planeRig.position);

      // Rings collection check
      if(currentRingObj) {
          guideArrow.position.copy(planeRig.position).y += 60; guideArrow.lookAt(currentRingObj.position);
          if(planeRig.position.distanceTo(currentRingObj.position) < 150 && !ringClaimLocked) {
              ringClaimLocked = true; 
              socket.emit("mp_claim_ring", { roomId: mp.roomId, ringIndex: rings.indexOf(currentRingObj) });
          }
      }

      // Network sync tick
      if (now - lastNetworkTick > NETWORK_TICK_RATE) {
          socket.emit("playerMovement", { 
              roomId: mp.roomId, x: planeRig.position.x, y: planeRig.position.y, z: planeRig.position.z, 
              quaternion: planeRig.quaternion, rotX: visualPitch, rotZ: visualRoll, ts: now 
          });
          lastNetworkTick = now;
      }

      // Interpolation for other players
      const renderTimestamp = now - 100;
      Object.values(otherPlayers).forEach(p => {
          const buffer = p.userData.buffer;
          if (buffer && buffer.length >= 2) {
              let t1 = buffer[0], t2 = buffer[1];
              for(let i=0; i<buffer.length-1; i++) { if(buffer[i+1].time > renderTimestamp) { t1=buffer[i]; t2=buffer[i+1]; break; } }
              const alpha = (renderTimestamp - t1.time) / (t2.time - t1.time);
              p.position.lerpVectors(t1.pos, t2.pos, alpha); 
              p.quaternion.slerpQuaternions(t1.quat, t2.quat, alpha);
          }
      });

      miniTick++; if(miniTick >= 6) { drawMinimap(); miniTick=0; }
      renderer.render(scene, camera); 
      requestAnimationFrame(animate);
  }

  function respawnPlayer() {
      health = 100;
      const msg = document.getElementById("respawn-msg");
      msg.style.display = "block";
      setTimeout(() => msg.style.display = "none", 2000);
      planeRig.position.y += 400;
      if (typeof SFXManager !== 'undefined') SFXManager.playExplosion(isSfxEnabled());
  }

  function updateLeaderboard() {
      const list = document.getElementById('leaderboard-list'); 
      if(!list) return; 
      list.innerHTML = "";
      const sorted = Object.keys(allScores).sort((a,b) => allScores[b].rings - allScores[a].rings);
      sorted.forEach((id, i) => {
          const s = allScores[id]; const row = document.createElement("div"); row.className = "lb-row";
          if(id === socket.id) row.classList.add("lb-player");
          if(i === 0) row.classList.add("lb-rank-1");
          row.innerHTML = `<span>${i+1}. ${s.name}</span><span>${s.rings}/${Cfg.TOTAL_RINGS_WIN}</span>`;
          list.appendChild(row);
      });
  }

  function endGame(win, winner) { 
      isPlaying = false; 
      showScreen("end-screen");
      const title = document.getElementById("end-title");
      title.innerText = win ? "MISSION SUCCESS" : "MISSION FAILURE";
      title.className = win ? "win-text" : "lose-text";
      document.getElementById("end-msg").innerText = win ? "Aapne asmaan jeet liya!" : winner + " ne race jeet li.";
      if(win && MusicManager.playWin) MusicManager.playWin(); 
      else if(MusicManager.playLose) MusicManager.playLose();
  }

  function drawMinimap() { 
      if(!minimapCtx || !planeRig) return; 
      minimapCtx.clearRect(0,0,140,140); 
      const cx=70, cy=70, scale=60/5000; 
      minimapCtx.save(); 
      minimapCtx.translate(cx,cy); 
      minimapCtx.rotate(-planeRig.rotation.y+Math.PI); 
      minimapCtx.beginPath(); 
      minimapCtx.moveTo(0,-6); minimapCtx.lineTo(-4,4); minimapCtx.lineTo(4,4); 
      minimapCtx.fillStyle="#00ff00"; minimapCtx.fill(); 
      minimapCtx.restore(); 
  }

  function setKey(action, state) { 
      const binds = getBindings(); 
      if(action === "boost") { activeKeys[binds.boost] = state; activeKeys["Space"] = state; return; } 
      if(action === "fire") { activeKeys[binds.fire] = state; activeKeys["shift"] = state; activeKeys["Shift"] = state; return; } 
      activeKeys[binds[action]] = state; 
  }
  function isActionActive(id) { 
      const binds = getBindings(); 
      if(id === 'boost') return activeKeys[binds.boost] || activeKeys[" "] || activeKeys["Space"]; 
      if(id === 'fire') return activeKeys[binds.fire] || activeKeys["shift"] || activeKeys["Shift"]; 
      return activeKeys[binds[id]] || activeKeys['arrow'+id]; 
  }
  function getBindings() { 
      if (window.GameManager && window.GameManager.data && window.GameManager.data.bindings) return window.GameManager.data.bindings; 
      return { up:'w', down:'s', left:'a', right:'d', boost:' ', fire:'shift' }; 
  }
  function togglePause() { 
      if(!isPlaying) return; 
      isPaused = !isPaused; 
      document.getElementById('pause-screen').classList.toggle('hidden', !isPaused); 
      if(!isPaused) requestAnimationFrame(animate); 
  }
  
  window.addEventListener('resize', () => { 
      if(camera && renderer) { 
          camera.aspect = window.innerWidth/window.innerHeight; 
          camera.updateProjectionMatrix(); 
          renderer.setSize(window.innerWidth, window.innerHeight); 
      } 
  });
</script>
</body>
</html>
