<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Sky Pilot - Multiplayer</title>
  
  <link rel="icon" href="data:,">

  <!-- Socket.IO client -->
  <script src="https://cdn.socket.io/4.7.4/socket.io.min.js"></script>
  <!-- THREE.JS LIBRARY -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

  <!-- âœ… LINKING CONFIG & GLOBAL MANAGERS -->
  <script src="game-config.js"></script>
  <script src="music-manager.js"></script>
  <script src="sfx-manager.js"></script>
  <!-- Optional: game-manager.js for general logic/settings -->
  <script src="game-manager.js"></script>

  <style>
    body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; user-select: none; touch-action: none; }
    #game-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }

    #ui-layer {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      pointer-events: none;
      display: flex; flex-direction: column; justify-content: space-between;
      padding: 20px; box-sizing: border-box;
    }

    .hud-top { display: flex; justify-content: space-between; align-items: flex-start; }
    .left-hud { display: flex; flex-direction: column; align-items: flex-start; gap: 15px; }
    .right-hud { display: flex; flex-direction: column; align-items: flex-end; gap: 10px; pointer-events: auto; }
    .top-right-row { display: flex; align-items: flex-start; gap: 15px; }

    .leaderboard-box {
      background: rgba(0,0,0,0.6); padding: 15px; border-radius: 10px;
      color: white; min-width: 220px; pointer-events: none; backdrop-filter: blur(4px);
      border-left: 5px solid #ffd700;
    }
    .lb-title { font-weight: 900; font-size: 14px; color: #ffd700; border-bottom: 1px solid #555; padding-bottom: 5px; margin-bottom: 8px; letter-spacing: 1px; }
    .lb-row { display: flex; justify-content: space-between; font-size: 14px; margin-bottom: 4px; font-weight: bold; }
    .lb-name { color: #ddd; }
    .lb-score { color: #fff; font-family: monospace; }
    .lb-player { color: #00ff00; text-shadow: 0 0 5px #00ff00; }
    .lb-rank-1 { color: #ffd700; }

    .pause-btn { background: rgba(0,0,0,0.6); color: white; border: 2px solid white; width: 40px; height: 40px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; cursor: pointer; transition: 0.2s; pointer-events: auto; }
    .pause-btn:hover { background: white; color: black; box-shadow: 0 0 15px white; }

    .bar-container { width: 220px; text-align: left; pointer-events: none; }
    .right-hud .bar-container { text-align: right; }
    .bar-label { font-weight: 900; font-size: 14px; margin-bottom: 3px; letter-spacing: 1px; text-shadow: 0 0 5px black; }
    .bar-bg { width: 100%; height: 12px; background: rgba(0,0,0,0.6); border: 1px solid #444; border-radius: 6px; overflow: hidden; transform: skewX(-20deg); box-shadow: 0 0 5px rgba(0,0,0,0.5); }
    #health-fill { width: 100%; height: 100%; background: linear-gradient(90deg, #cc0000, #00ff00); box-shadow: 0 0 10px #00ff00; transition: width 0.1s linear; }
    #boost-fill { width: 100%; height: 100%; background: linear-gradient(90deg, #0066ff, #00d2ff); box-shadow: 0 0 15px #00d2ff; transition: width 0.1s linear; }

    #fps-counter { background: rgba(0,0,0,0.5); color: #00ff00; padding: 5px 10px; border-radius: 5px; font-family: monospace; font-weight: bold; font-size: 12px; pointer-events: none; margin-bottom: 5px; }

    #respawn-msg { position: absolute; top: 30%; width: 100%; text-align: center; color: #ff4444; font-size: 40px; font-weight: 900; text-shadow: 0 0 20px black; display: none; animation: blink 0.5s infinite alternate; }
    @keyframes blink { from { opacity: 1; } to { opacity: 0.2; } }

    #minimap-container { position: absolute; bottom: 20px; left: 20px; width: 140px; height: 140px; background: rgba(0,10,30,0.8); border: 2px solid #00d2ff; border-radius: 50%; overflow: hidden; pointer-events: none; box-shadow: 0 0 15px rgba(0,210,255,0.3); }
    #minimap-canvas { width: 100%; height: 100%; }

    .mobile-controls { display: none; position: absolute; bottom: 20px; width: 100%; padding: 0 20px; box-sizing: border-box; justify-content: space-between; pointer-events: none; z-index: 100; }
    @media (max-width: 1024px) { .mobile-controls { display: flex; } }
    .control-group { pointer-events: auto; display: flex; gap: 10px; }
    .dpad { display: grid; grid-template-columns: 60px 60px 60px; grid-template-rows: 60px 60px; gap: 5px; }
    .mob-btn { width: 60px; height: 60px; background: rgba(255,255,255,0.1); border: 2px solid rgba(255,255,255,0.3); border-radius: 50%; color: white; font-weight: bold; font-size: 20px; display: flex; align-items: center; justify-content: center; user-select: none; backdrop-filter: blur(4px); }
    .mob-btn:active { background: rgba(0, 210, 255, 0.4); border-color: #00d2ff; transform: scale(0.95); }
    .mob-btn-rect { width: 80px; height: 60px; border-radius: 15px; font-size: 14px; }
    .mob-fire { border-color: #ff4444; } .mob-fire:active { background: rgba(255, 0, 0, 0.3); }
    .mob-boost { border-color: #00d2ff; }
    .btn-up { grid-column: 2; grid-row: 1; } .btn-left { grid-column: 1; grid-row: 2; } .btn-down { grid-column: 2; grid-row: 2; } .btn-right { grid-column: 3; grid-row: 2; }

    .screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); backdrop-filter: blur(8px); display: flex; flex-direction: column; align-items: center; justify-content: center; pointer-events: auto; z-index: 10; }
    .hidden { display: none !important; }
    .menu-box { background: rgba(12, 20, 30, 0.85); border: 2px solid #00d2ff; border-radius: 20px; padding: 40px; text-align: center; box-shadow: 0 0 50px rgba(0, 210, 255, 0.25), inset 0 0 30px rgba(0, 210, 255, 0.1); width: 550px; max-width: 90%; max-height: 90vh; overflow-y: auto; }
    
    h1 { font-size: 56px; color: #fff; text-transform: uppercase; margin: 0 0 10px 0; font-weight: 900; letter-spacing: 4px; text-shadow: 0 0 20px #00d2ff; font-style: italic; }
    .action-btn { display: block; width: 100%; padding: 18px 0; margin: 15px 0; background: linear-gradient(135deg, #00d2ff, #0077ff); border: none; color: #fff; border-radius: 50px; font-size: 20px; font-weight: 900; cursor: pointer; text-transform: uppercase; letter-spacing: 2px; box-shadow: 0 5px 20px rgba(0, 210, 255, 0.4); transition: all 0.2s cubic-bezier(0.25, 0.8, 0.25, 1); }
    .action-btn:hover { transform: translateY(-2px) scale(1.02); box-shadow: 0 10px 40px rgba(0, 210, 255, 0.6); filter: brightness(1.2); }
    .secondary-btn { background: rgba(255,255,255,0.05); border: 1px solid #555; box-shadow: none; font-size: 16px; }
    .secondary-btn:hover { background: rgba(255,255,255,0.15); border-color: #fff; }

    input { margin-top: 10px; padding: 12px; width: 80%; border-radius: 5px; border: none; background: rgba(255,255,255,0.1); color: #fff; font-size: 16px; font-weight: bold; text-align: center; }
  </style>
</head>
<body>

  <div id="game-container"></div>
  <div id="respawn-msg">SYSTEM FAILURE - REBOOTING</div>

  <div id="ui-layer">
    <div class="hud-top">
      <div class="left-hud">
        <div id="fps-counter">FPS: 0</div>
        <div class="bar-container">
          <div class="bar-label" style="color:#00ff00;">HEALTH</div>
          <div class="bar-bg"><div id="health-fill"></div></div>
        </div>
        <div class="leaderboard-box">
          <div class="lb-title">RACE RANKING</div>
          <div id="leaderboard-list"></div>
        </div>
      </div>
      <div class="right-hud">
        <div class="top-right-row">
          <div class="bar-container">
            <div class="bar-label" style="color:#00d2ff;">BOOST</div>
            <div class="bar-bg"><div id="boost-fill"></div></div>
          </div>
          <div class="pause-btn" onclick="togglePause()">||</div>
        </div>
      </div>
    </div>
    <div id="minimap-container"><canvas id="minimap-canvas" width="140" height="140"></canvas></div>

    <div class="mobile-controls">
        <div class="control-group dpad">
            <div class="mob-btn btn-up" ontouchstart="setKey('up', true)" ontouchend="setKey('up', false)">â–²</div>
            <div class="mob-btn btn-left" ontouchstart="setKey('left', true)" ontouchend="setKey('left', false)">â—€</div>
            <div class="mob-btn btn-down" ontouchstart="setKey('down', true)" ontouchend="setKey('down', false)">â–¼</div>
            <div class="mob-btn btn-right" ontouchstart="setKey('right', true)" ontouchend="setKey('right', false)">â–¶</div>
        </div>
        <div class="control-group" style="flex-direction: column; justify-content: flex-end;">
            <div class="mob-btn mob-btn-rect mob-fire" ontouchstart="setKey('fire', true)" ontouchend="setKey('fire', false)">FIRE</div>
            <div class="mob-btn mob-btn-rect mob-boost" ontouchstart="setKey('boost', true)" ontouchend="setKey('boost', false)">BOOST</div>
        </div>
    </div>
  </div>

  <!-- MULTIPLAYER MENU -->
  <div id="mp-menu-screen" class="screen">
    <div class="menu-box">
      <h1>MULTIPLAYER</h1>
      <button class="action-btn" onclick="mpCreateRoom()">CREATE ROOM</button>
      <input id="mp-room-code" placeholder="Enter Room Code" />
      <button class="action-btn secondary-btn" onclick="mpJoinRoom()">JOIN ROOM</button>
      <button class="action-btn secondary-btn" onclick="window.location.href='index.html'">BACK</button>
    </div>
  </div>

  <!-- LOBBY SCREEN -->
  <div id="lobby-screen" class="screen hidden">
    <div class="menu-box">
      <h1>LOBBY</h1>
      <div style="color:#00d2ff; font-weight:800;">ROOM: <span id="lobby-room-id">----</span></div>
      <div id="lobby-player-list" style="text-align:left; color:#ddd; margin:15px 0;"></div>
      <button id="host-start-btn" class="action-btn hidden" onclick="mpHostStartGame()">START GAME</button>
      <button class="action-btn secondary-btn" onclick="mpLeaveLobby()">LEAVE</button>
    </div>
  </div>

  <!-- COUNTDOWN -->
  <div id="countdown-screen" class="screen hidden">
    <div class="menu-box">
      <h1 id="countdown-text" style="font-size:90px;">3</h1>
      <p style="color:#00d2ff;">GET READY</p>
    </div>
  </div>

  <!-- END -->
  <div id="end-screen" class="screen hidden">
    <div class="menu-box">
      <h1 id="end-title" class="win-text">VICTORY</h1>
      <p id="end-msg" style="color:#fff; font-size: 20px;">Rank 1 Secured.</p>
      <button class="action-btn" onclick="location.reload()">MAIN MENU</button>
    </div>
  </div>

<script>
  document.body.addEventListener("touchmove", e => e.preventDefault(), { passive: false });

  // âœ… CONFIG & SETTINGS SYNC (Shift=Boost, Space=Fire)
  const GM = (window.GameManager && GameManager.data) ? GameManager : { 
      data: { music: true, sfx: true, bindings: { up:'w', down:'s', left:'a', right:'d', boost:'shift', fire:' ' } } 
  };
  const BULLET_GEO = new THREE.SphereGeometry(2, 8, 8);
  const BULLET_MAT_MY = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
  const BULLET_MAT_ENEMY = new THREE.MeshBasicMaterial({ color: 0xff0000 });
  const BULLET_SPEED = 8000;
  const TMP_VEC3 = new THREE.Vector3();

  let gameSeed = null; 
  function seededRandom() { gameSeed = (gameSeed * 9301 + 49297) % 233280; return gameSeed / 233280; }

  // --- MP STATE ---
  let mp = { roomId: null, isHost: false, playerName: null };
  const otherPlayers = {}, playersData = {}, allScores = {}; 
  let lastNetworkTick = 0, NETWORK_TICK_RATE = 50, lastCrashTime = 0; 
  let socket = (typeof io !== "undefined") ? io() : { emit(){}, on(){} };

  // âœ… FIX 6: Helper to hide all screens
  function hideAllScreens() {
      document.querySelectorAll(".screen").forEach(s => s.classList.add("hidden"));
  }

  function showScreen(id) { 
      hideAllScreens();
      const el = document.getElementById(id); 
      if (el) el.classList.remove("hidden"); 
  }

  function mpCreateRoom() { 
      MusicManager.init(); SFXManager.init();
      if (GM.data.music) MusicManager.playLobby(); 
      mp.playerName = prompt("Enter your name:", "ACE") || "ACE"; 
      socket.emit("mp_create_room", { name: mp.playerName }); 
  }
  
  function mpJoinRoom() { 
      MusicManager.init(); SFXManager.init();
      if (GM.data.music) MusicManager.playLobby(); 
      mp.playerName = prompt("Enter your name:", "ROOKIE") || "ROOKIE"; 
      const room = (document.getElementById("mp-room-code").value || "").trim(); 
      if (!room) return alert("Enter Room Code"); 
      socket.emit("mp_join_room", { roomId: room, name: mp.playerName }); 
  }

  function mpLeaveLobby() { 
      if (!mp.roomId) return showScreen("mp-menu-screen"); 
      socket.emit("mp_leave_room", { roomId: mp.roomId }); 
      mp.roomId = null; showScreen("mp-menu-screen"); 
      MusicManager.stop();
  }
  
  function mpHostStartGame() { if (mp.isHost) socket.emit("mp_start_game", { roomId: mp.roomId, seed: Math.floor(Math.random() * 100000) }); }
  
  function mpCountdownThenStart() { 
      let n = 3; const txt = document.getElementById("countdown-text"); 
      const timer = setInterval(() => { 
          n--; if (n > 0) txt.innerText = n; 
          else if (n === 0) txt.innerText = "GO!"; 
          else { clearInterval(timer); initMultiplayerGame(); } 
      }, 1000); 
  }
  
  function initMultiplayerGame() { if (typeof gameSeed !== "number") return setTimeout(initMultiplayerGame, 50); initGame(); hideAllScreens(); }

  // --- SOCKETS ---
  socket.on("mp_room_created", ({ roomId, players, hostId }) => { updateLobbyUI(roomId, players, hostId); });
  socket.on("mp_room_joined", ({ roomId, players, hostId }) => { updateLobbyUI(roomId, players, hostId); });
  socket.on("mp_lobby_update", ({ roomId, players, hostId }) => { if (mp.roomId === roomId) updateLobbyUI(roomId, players, hostId); });

  function updateLobbyUI(roomId, players, hostId) {
      mp.roomId = roomId; mp.isHost = (socket.id === hostId); 
      document.getElementById("lobby-room-id").innerText = roomId; 
      const list = document.getElementById("lobby-player-list"); list.innerHTML = "";
      players.forEach(p => { const div = document.createElement("div"); div.textContent = `${p.name}${p.isHost ? " (HOST) ðŸ‘‘" : ""}`; list.appendChild(div); });
      document.getElementById("host-start-btn").classList.toggle("hidden", !mp.isHost); 
      showScreen("lobby-screen");
  }

  socket.on("mp_game_starting", (data) => { if(data && data.seed) gameSeed = data.seed; showScreen("countdown-screen"); mpCountdownThenStart(); });

  socket.on("currentPlayers", (players) => { 
      Object.keys(players).forEach((id) => { if (id !== socket.id) addOtherPlayer(players[id]); allScores[id] = { name: players[id].name, rings: 0 }; }); 
      if(!allScores[socket.id]) allScores[socket.id] = { name: mp.playerName, rings: 0 };
      updateLeaderboard();
  });

  socket.on("newPlayer", (p) => { addOtherPlayer(p); allScores[p.playerId] = { name: p.name, rings: 0 }; updateLeaderboard(); });
  socket.on("playerDisconnected", (id) => { removeOtherPlayer(id); delete allScores[id]; updateLeaderboard(); });
  
  socket.on("playerMoved", (info) => { 
      const id = info.playerId || info.id; if (!id || !otherPlayers[id]) return;
      const p = otherPlayers[id];
      const snap = { time: info.ts || Date.now(), pos: new THREE.Vector3(info.x, info.y, info.z), quat: new THREE.Quaternion(info.quaternion.x, info.quaternion.y, info.quaternion.z, info.quaternion.w), roll: info.rotZ || 0, pitch: info.rotX || 0 };
      if (!p.userData.buffer) p.userData.buffer = []; p.userData.buffer.push(snap);
      if (p.userData.buffer.length > 5) p.userData.buffer.shift();
  });

  socket.on('mp_game_over', ({ winnerName, winnerId }) => { endGame(winnerId === socket.id, winnerId === socket.id ? "Champion!" : winnerName + " Won!"); });

  socket.on('mp_score_update', ({ playerId, rings, nextRingIndex }) => {
      if (allScores[playerId]) {
          allScores[playerId].rings = rings; updateLeaderboard();
          if(playerId === socket.id) { playerStats.rings = rings; playerStats.progress = (nextRingIndex !== undefined) ? nextRingIndex : rings; updateRingVisuals(); SFXManager.playRing(GM.data.sfx); }
      }
  });

  socket.on('mp_player_fire', (data) => { if (data.shooterId !== socket.id) spawnNetworkBullet(new THREE.Vector3(data.startPos.x, data.startPos.y, data.startPos.z), new THREE.Quaternion(data.quaternion.x, data.quaternion.y, data.quaternion.z, data.quaternion.w)); });

  socket.on('mp_kit_collected', ({ kitIndex, collectorId }) => { if (repairKits[kitIndex]) { repairKits[kitIndex].visible = false; if(collectorId === socket.id) { health = Math.min(100, health + 30); SFXManager.playRepair(GM.data.sfx); } } });
  socket.on('mp_kit_restored', ({ kitIndex }) => { if (repairKits[kitIndex]) repairKits[kitIndex].visible = true; });

  // --- GAMEPLAY ---
  let scene, camera, renderer, planeRig, planeMesh, guideArrow;
  let rings = [], ringWaypoints = [], currentRingObj = null, repairKits = [], bullets = [];
  let isPlaying = false, isPaused = false, lastRender = 0;
  let boostLevel = 100, health = 100, lastFireTime = 0;
  const activeKeys = {}; let visualRoll = 0, visualPitch = 0;
  let playerStats = { name: "PLAYER", rings: 0, progress: 0 };
  let lastFrameTime = performance.now(), frameCount = 0;
  const fpsElem = document.getElementById('fps-counter'), minimapCtx = document.getElementById('minimap-canvas').getContext('2d');

  // âœ… FIX 1: Mobile key helper
  function setKey(action, state) { 
      activeKeys[action] = state; 
  }

  // âœ… FIX 2: Toggle Pause function
  function togglePause() {
      if(!isPlaying) return;
      isPaused = !isPaused;
      if(!isPaused) {
          lastRender = performance.now();
          requestAnimationFrame(animate);
      }
  }

  // âœ… FIX 3: Leaderboard logic
  function updateLeaderboard() {
      const list = document.getElementById("leaderboard-list");
      if(!list) return;
      list.innerHTML = "";

      const racers = Object.entries(allScores).map(([id, s]) => ({
          id, name: s.name || "Player", rings: s.rings || 0
      }));

      racers.sort((a,b) => b.rings - a.rings);

      racers.forEach((r, i) => {
          const row = document.createElement("div");
          row.className = "lb-row";
          const n = document.createElement("span");
          n.className = "lb-name";
          if(r.id === socket.id) n.classList.add("lb-player");
          if(i === 0) n.classList.add("lb-rank-1");
          n.innerText = `${i+1}. ${r.name}`;
          const sc = document.createElement("span");
          sc.className = "lb-score";
          sc.innerText = `${r.rings}/${TOTAL_RINGS_WIN}`;
          row.appendChild(n); row.appendChild(sc);
          list.appendChild(row);
      });
  }

  window.addEventListener('keydown', (e) => { 
      if(e.key === "Escape") { togglePause(); return; } 
      if(isPaused) return; 
      const k = e.key.toLowerCase(); const b = GM.data.bindings;
      if(k === b.up || k === 'arrowup') activeKeys['up'] = true; 
      if(k === b.down || k === 'arrowdown') activeKeys['down'] = true; 
      if(k === b.left || k === 'arrowleft') activeKeys['left'] = true; 
      if(k === b.right || k === 'arrowright') activeKeys['right'] = true; 
      if(k === b.boost || (b.boost === 'shift' && (e.code==='ShiftLeft'||e.code==='ShiftRight'))) activeKeys['boost'] = true; 
      if(k === b.fire || (b.fire === ' ' && e.code === 'Space')) activeKeys['fire'] = true; 
  });
  window.addEventListener('keyup', (e) => { 
      const k = e.key.toLowerCase(); const b = GM.data.bindings;
      if(k === b.up || k === 'arrowup') activeKeys['up'] = false; 
      if(k === b.down || k === 'arrowdown') activeKeys['down'] = false; 
      if(k === b.left || k === 'arrowleft') activeKeys['left'] = false; 
      if(k === b.right || k === 'arrowright') activeKeys['right'] = false; 
      if(k === b.boost || (b.boost === 'shift' && (e.code==='ShiftLeft'||e.code==='ShiftRight'))) activeKeys['boost'] = false; 
      if(k === b.fire || (b.fire === ' ' && e.code === 'Space')) activeKeys['fire'] = false; 
  });

  function initGame() {
    if (typeof TERRAIN_COLORS === 'undefined') return alert("Config missing!");
    const container = document.getElementById('game-container'); 
    if (scene) scene.clear();
    rings = []; repairKits = []; bullets = []; ringWaypoints = [];
    scene = new THREE.Scene(); scene.background = new THREE.Color(0x87CEEB); scene.fog = new THREE.Fog(0x87CEEB, 1500, 7000); 
    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 20000); 
    renderer = new THREE.WebGLRenderer({ antialias: true }); renderer.setSize(window.innerWidth, window.innerHeight); renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.25)); container.innerHTML = ""; container.appendChild(renderer.domElement);
    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6); scene.add(hemiLight);
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8); dirLight.position.set(100, 200, 50); scene.add(dirLight);
    
    generateTerrain(); generateOcean(); createPlaneSystem(); createGuideArrow(); createRepairKits(); createRings(); updateRingVisuals(); updateLeaderboard();
    
    if (GM.data.music) MusicManager.updateGameplayMusic(health);
    isPlaying = true; lastRender = performance.now(); animate();
  }

  function fireBullet() {
      SFXManager.playGun(GM.data.sfx);
      const b = new THREE.Mesh(BULLET_GEO, BULLET_MAT_MY); b.position.copy(planeRig.position); b.quaternion.copy(planeRig.quaternion);
      const vel = new THREE.Vector3(0, 0, -BULLET_SPEED).applyQuaternion(planeRig.quaternion);
      b.userData = { velocity: vel, life: 1.5, isMine: true }; scene.add(b); bullets.push({ mesh: b });
      socket.emit('mp_player_fire', { roomId: mp.roomId, shooterId: socket.id, startPos: { x: b.position.x, y: b.position.y, z: b.position.z }, quaternion: { x: b.quaternion.x, y: b.quaternion.y, z: b.quaternion.z, w: b.quaternion.w } });
  }

  function spawnNetworkBullet(pos, quat) {
      SFXManager.playGun(GM.data.sfx);
      const b = new THREE.Mesh(BULLET_GEO, BULLET_MAT_ENEMY); b.position.copy(pos); b.quaternion.copy(quat);
      const vel = new THREE.Vector3(0, 0, -BULLET_SPEED).applyQuaternion(quat);
      b.userData = { velocity: vel, life: 1.5, isMine: false }; scene.add(b); bullets.push({ mesh: b });
  }

  function animate() {
    if (!isPlaying || isPaused) return;
    const nowPerf = performance.now();
    const dt = Math.min((nowPerf - lastRender) / 1000, 0.05); lastRender = nowPerf;
    
    frameCount++; if (nowPerf - lastFrameTime >= 1000) { if (fpsElem) fpsElem.innerText = "FPS: " + frameCount; frameCount = 0; lastFrameTime = nowPerf; }
    const now = Date.now();

    // âœ… FIX 4: Safely stop music manager
    if (GM.data.music) {
        MusicManager.updateGameplayMusic(health);
    } else {
        if (MusicManager.currentTheme !== null) MusicManager.stop();
    }

    const isBoosting = activeKeys['boost'] && boostLevel > 0;
    SFXManager.updateContinuous(isBoosting, health < 30, GM.data.sfx);

    if (activeKeys['fire'] && now - lastFireTime > FIRE_RATE) { lastFireTime = now; fireBullet(); }

    for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i].mesh; b.position.addScaledVector(b.userData.velocity, dt); b.userData.life -= dt;
        if (b.userData.life <= 0) { scene.remove(b); bullets.splice(i, 1); continue; }
        if (!b.userData.isMine && b.position.distanceToSquared(planeRig.position) < 900) {
            health -= 10; SFXManager.playExplosion(GM.data.sfx); scene.remove(b); bullets.splice(i, 1);
            if(health <= 0) respawnPlayer();
        }
    }

    // Movement (DT Based x60)
    let spd = (isBoosting ? BOOST_SPEED : NORMAL_SPEED) * dt * 60;
    if (isBoosting) boostLevel -= BOOST_DRAIN * dt * 60; 
    else boostLevel += BOOST_REFILL * dt * 60;

    // âœ… FIX A: Boost clamp
    boostLevel = THREE.MathUtils.clamp(boostLevel, 0, 100);
    document.getElementById('boost-fill').style.width = boostLevel + '%';
    planeRig.translateZ(-spd);

    // âœ… FIX 5: DT-based turning and lifting
    if (activeKeys['left']) { planeRig.rotation.y += TURN_SPEED * dt * 60; visualRoll = THREE.MathUtils.lerp(visualRoll, 0.8, 0.1); }
    else if (activeKeys['right']) { planeRig.rotation.y -= TURN_SPEED * dt * 60; visualRoll = THREE.MathUtils.lerp(visualRoll, -0.8, 0.1); }
    else visualRoll = THREE.MathUtils.lerp(visualRoll, 0, 0.1);

    if (activeKeys['up']) { planeRig.position.y += LIFT_SPEED * dt * 60; visualPitch = THREE.MathUtils.lerp(visualPitch, -0.5, 0.1); }
    else if (activeKeys['down']) { planeRig.position.y -= LIFT_SPEED * dt * 60; visualPitch = THREE.MathUtils.lerp(visualPitch, 0.5, 0.1); }
    else visualPitch = THREE.MathUtils.lerp(visualPitch, 0, 0.1);

    const gh = getTerrainHeight(planeRig.position.x, planeRig.position.z);
    if (planeRig.position.y < gh + 15) { 
        planeRig.position.y = gh + 15; 
        if (now - lastCrashTime > 500) { 
            health -= COLLISION_DAMAGE; 
            lastCrashTime = now; 
            if (health <= 0) respawnPlayer(); 
        } 
    }

    // âœ… FIX B: Health UI update
    document.getElementById("health-fill").style.width = health + "%";

    const renderTs = now - 100;
    Object.values(otherPlayers).forEach(p => {
        const buf = p.userData.buffer;
        if (buf && buf.length >= 2) {
            let t1 = buf[0], t2 = buf[1], i = 0;
            while (i < buf.length - 1 && buf[i+1].time <= renderTs) { t1 = buf[i]; t2 = buf[i+1]; i++; }
            if (t2.time >= renderTs) {
                const alpha = (renderTs - t1.time) / (t2.time - t1.time);
                p.position.lerpVectors(t1.pos, t2.pos, alpha); p.quaternion.slerpQuaternions(t1.quat, t2.quat, alpha);
                if(p.children[0]) { p.children[0].rotation.z = THREE.MathUtils.lerp(t1.roll, t2.roll, alpha); p.children[0].rotation.x = THREE.MathUtils.lerp(t1.pitch, t2.pitch, alpha); }
            }
        }
    });

    planeMesh.rotation.z = visualRoll; planeMesh.rotation.x = visualPitch;
    const targetCam = new THREE.Vector3(0, 100, 300).applyMatrix4(planeRig.matrixWorld); camera.position.lerp(targetCam, 0.1); camera.lookAt(planeRig.position);
    
    if (currentRingObj && planeRig.position.distanceTo(currentRingObj.position) < 150) ringCollected();
    
    if (mp.roomId && (now - lastNetworkTick > NETWORK_TICK_RATE)) { socket.emit("playerMovement", { roomId: mp.roomId, x: planeRig.position.x, y: planeRig.position.y, z: planeRig.position.z, rotX: visualPitch, rotZ: visualRoll, quaternion: { x: planeRig.quaternion.x, y: planeRig.quaternion.y, z: planeRig.quaternion.z, w: planeRig.quaternion.w } }); lastNetworkTick = now; }

    renderer.render(scene, camera); requestAnimationFrame(animate);
  }

  function respawnPlayer() { 
      health = 100; 
      SFXManager.playExplosion(GM.data.sfx); 
      planeRig.position.y += 300; 
      const msg = document.getElementById("respawn-msg"); 
      msg.style.display = "block"; 
      setTimeout(() => msg.style.display = "none", 2000); 
  }

  function ringCollected() { 
      // âœ… FIX C: Local prediction to avoid delay artifacts
      playerStats.progress++;
      updateRingVisuals();
      socket.emit('mp_ring_collected', { roomId: mp.roomId, playerId: socket.id }); 
  }

  function endGame(win, reason) { isPlaying = false; SFXManager.stopAll(); if(win) MusicManager.playWin(); else MusicManager.playLose(); showScreen("end-screen"); document.getElementById('end-title').innerText = win ? "VICTORY" : "DEFEAT"; document.getElementById('end-msg').innerText = reason; }
  
  function getTerrainHeight(x, z) { let y = Math.sin(x * 0.001) * Math.cos(z * 0.001) * 1000 + Math.sin(x * 0.005) * 200; if (z > -1000 && z < 1000 && x > -1000 && x < 1000) y *= 0.1; if (y < -150) y = -150; return y - 50; }
  function generateTerrain() { const geometry = new THREE.PlaneGeometry(50000, 50000, 100, 100); geometry.rotateX(-Math.PI / 2); const pos = geometry.attributes.position; const colors = []; for (let i = 0; i < pos.count; i++) { let y = getTerrainHeight(pos.getX(i), pos.getZ(i)); pos.setY(i, y); const c = new THREE.Color(); if (y < 100) c.setHex(TERRAIN_COLORS.SAND); else if (y < 500) c.setHex(TERRAIN_COLORS.GRASS); else c.setHex(TERRAIN_COLORS.ROCK); colors.push(c.r, c.g, c.b); } geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3)); geometry.computeVertexNormals(); scene.add(new THREE.Mesh(geometry, new THREE.MeshStandardMaterial({ vertexColors: true, roughness: 0.8, flatShading: true }))); }
  function generateOcean() { const geo = new THREE.PlaneGeometry(50000, 50000); geo.rotateX(-Math.PI / 2); scene.add(new THREE.Mesh(geo, new THREE.MeshBasicMaterial({ color: TERRAIN_COLORS.WATER, transparent: true, opacity: 0.6 }))); }
  function createPlaneMesh(col) { const g = new THREE.Group(); const mat = new THREE.MeshStandardMaterial({ color: col }); const b = new THREE.Mesh(new THREE.CylinderGeometry(2, 4, 30, 8), mat); b.rotateX(-Math.PI/2); g.add(b); const w = new THREE.Mesh(new THREE.BoxGeometry(20, 0.5, 15), mat); w.position.set(0, 0, 5); g.add(w); return g; }
  function createPlaneSystem() { planeRig = new THREE.Group(); planeRig.position.set(0, 400, 800); scene.add(planeRig); planeMesh = createPlaneMesh(0x555555); planeRig.add(planeMesh); }
  function createGuideArrow() { guideArrow = new THREE.Group(); guideArrow.add(new THREE.Mesh(new THREE.ConeGeometry(4, 8, 8), new THREE.MeshBasicMaterial({ color: 0x00ff00 }))); scene.add(guideArrow); }
  function createRings() { for(let i=0; i<RINGS_PER_LAP; i++) { const a = i * (Math.PI * 2 / RINGS_PER_LAP); const x = Math.sin(a) * 12000, z = Math.cos(a) * -12000; ringWaypoints.push({x, y: Math.max(500, getTerrainHeight(x, z)+400), z}); const r = new THREE.Mesh(new THREE.TorusGeometry(80, 10, 16, 50), new THREE.MeshPhongMaterial({ color: 0xFFD700, emissive: 0xffaa00 })); r.position.set(x, ringWaypoints[i].y, z); scene.add(r); rings.push(r); } }
  function updateRingVisuals() { const cur = playerStats.progress % RINGS_PER_LAP; rings.forEach((r, i) => { r.visible = (i === cur); if(r.visible) currentRingObj = r; }); }
  function createRepairKits() { const box = new THREE.Mesh(new THREE.BoxGeometry(60, 60, 60), new THREE.MeshPhongMaterial({ color: 0x00aa00 })); [{ x: 1000, z: -3000 }, { x: -2000, z: -6000 }].forEach((loc, id) => { const k = box.clone(); k.position.set(loc.x, 400, loc.z); k.userData = { id }; scene.add(k); repairKits.push(k); }); }
  function addOtherPlayer(p) { const id = p.playerId; if (!id || otherPlayers[id]) return; const m = createPlaneMesh(0xff0000); m.position.set(p.x||0, p.y||400, p.z||0); m.userData={buffer:[]}; scene.add(m); otherPlayers[id] = m; }
  function removeOtherPlayer(id) { if (otherPlayers[id]) { scene.remove(otherPlayers[id]); delete otherPlayers[id]; } }
  window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
</script>
</body>
</html>
