<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Sky Pilot - Singleplayer Mission</title>
  
  <!-- THREE.JS LIBRARY -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  
  <!-- Config, Map aur Managers -->
  <script src="game-config.js"></script>
  <script src="map.js"></script>
  <script src="game-manager.js"></script>
  <script src="sfx-manager.js"></script>
  <script src="music-manager.js"></script>

  <style>
    body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; user-select: none; touch-action: none; }
    #game-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
    
    #ui-layer {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      pointer-events: none;
      display: flex; flex-direction: column; justify-content: space-between;
      padding: 20px; box-sizing: border-box;
    }

    .hud-top { display: flex; justify-content: space-between; align-items: flex-start; }
    .left-hud { display: flex; flex-direction: column; align-items: flex-start; gap: 15px; }
    .right-hud { display: flex; flex-direction: column; align-items: flex-end; gap: 10px; pointer-events: auto; }

    .leaderboard-box {
      background: rgba(0,0,0,0.6); padding: 15px; border-radius: 10px;
      color: white; min-width: 220px; backdrop-filter: blur(4px); border-left: 5px solid #ffd700;
    }
    .lb-title { font-weight: 900; font-size: 14px; color: #ffd700; border-bottom: 1px solid #555; padding-bottom: 5px; margin-bottom: 8px; letter-spacing: 1px; }
    .lb-row { display: flex; justify-content: space-between; font-size: 14px; margin-bottom: 4px; font-weight: bold; }
    .lb-player { color: #00ff00; text-shadow: 0 0 5px #00ff00; }
    .lb-rank-1 { color: #ffd700; }

    .bar-container { width: 220px; text-align: left; }
    .bar-bg { width: 100%; height: 12px; background: rgba(0,0,0,0.6); border: 1px solid #444; border-radius: 6px; overflow: hidden; transform: skewX(-20deg); }
    #health-fill { width: 100%; height: 100%; background: linear-gradient(90deg, #cc0000, #00ff00); transition: width 0.1s linear; }
    #boost-fill { width: 100%; height: 100%; background: linear-gradient(90deg, #0066ff, #00d2ff); transition: width 0.1s linear; }

    #fps-counter { background: rgba(0,0,0,0.5); color: #00ff00; padding: 5px 10px; border-radius: 5px; font-family: monospace; font-size: 12px; }
    .pause-btn { background: rgba(0,0,0,0.6); color: white; border: 2px solid white; width: 40px; height: 40px; border-radius: 50%; display: flex; align-items: center; justify-content: center; cursor: pointer; }

    #minimap-container { position: absolute; bottom: 20px; left: 20px; width: 140px; height: 140px; background: rgba(0,10,30,0.8); border: 2px solid #00d2ff; border-radius: 50%; overflow: hidden; }
    #minimap-canvas { width: 100%; height: 100%; }

    .mobile-controls { display: none; position: absolute; bottom: 20px; width: 100%; padding: 0 20px; box-sizing: border-box; justify-content: space-between; pointer-events: none; }
    @media (max-width: 1024px) { .mobile-controls { display: flex; } }
    .control-group { pointer-events: auto; display: flex; gap: 10px; }
    .dpad { display: grid; grid-template-columns: 60px 60px 60px; grid-template-rows: 60px 60px; gap: 5px; }
    .mob-btn { width: 60px; height: 60px; background: rgba(255,255,255,0.1); border: 2px solid rgba(255,255,255,0.3); border-radius: 50%; color: white; font-weight: bold; display: flex; align-items: center; justify-content: center; user-select: none; }
    .mob-btn:active { background: rgba(0, 210, 255, 0.4); }
    .mob-btn-rect { width: 80px; height: 60px; border-radius: 15px; }
    .btn-up { grid-column: 2; grid-row: 1; } .btn-left { grid-column: 1; grid-row: 2; } .btn-down { grid-column: 2; grid-row: 2; } .btn-right { grid-column: 3; grid-row: 2; }

    .screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); backdrop-filter: blur(10px); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 100; }
    .hidden { display: none !important; }
    .menu-box { background: rgba(15,25,35,0.9); border: 2px solid #00d2ff; border-radius: 20px; padding: 40px; text-align: center; width: 450px; }
    .action-btn { display: block; width: 100%; padding: 15px; margin: 15px 0; background: linear-gradient(135deg, #00d2ff, #0077ff); border: none; color: white; border-radius: 30px; font-weight: 900; cursor: pointer; text-transform: uppercase; }
    .secondary-btn { background: rgba(255,255,255,0.1); border: 1px solid #555; }
    .win-text { color: #00ff00; font-size: 50px; font-weight: 900; }
    .lose-text { color: #ff4444; font-size: 50px; font-weight: 900; }
  </style>
</head>
<body>

  <div id="game-container"></div>

  <!-- HUD Interface -->
  <div id="ui-layer">
    <div class="hud-top">
      <div class="left-hud">
        <div id="fps-counter">FPS: 0</div>
        <div class="bar-container">
          <div style="color:#00ff00; font-size:12px; margin-bottom:3px;">HEALTH</div>
          <div class="bar-bg"><div id="health-fill"></div></div>
        </div>
        <div class="leaderboard-box">
          <div class="lb-title">MISSION RANKING</div>
          <div id="leaderboard-list"></div>
        </div>
      </div>
      <div class="right-hud">
        <div style="display:flex; gap:15px; align-items:flex-start;">
          <div class="bar-container">
            <div style="color:#00d2ff; font-size:12px; margin-bottom:3px; text-align:right;">BOOST</div>
            <div class="bar-bg"><div id="boost-fill"></div></div>
          </div>
          <div class="pause-btn" onclick="togglePause()">||</div>
        </div>
      </div>
    </div>
    <div id="minimap-container"><canvas id="minimap-canvas" width="140" height="140"></canvas></div>
    
    <!-- Mobile Controls -->
    <div class="mobile-controls">
        <div class="control-group dpad">
            <div class="mob-btn btn-up" ontouchstart="setKey('up', true)" ontouchend="setKey('up', false)" ontouchcancel="setKey('up', false)">▲</div>
            <div class="mob-btn btn-left" ontouchstart="setKey('left', true)" ontouchend="setKey('left', false)" ontouchcancel="setKey('left', false)">◀</div>
            <div class="mob-btn btn-down" ontouchstart="setKey('down', true)" ontouchend="setKey('down', false)" ontouchcancel="setKey('down', false)">▼</div>
            <div class="mob-btn btn-right" ontouchstart="setKey('right', true)" ontouchend="setKey('right', false)" ontouchcancel="setKey('right', false)">▶</div>
        </div>
        <div class="control-group" style="flex-direction: column; justify-content: flex-end;">
            <div class="mob-btn mob-btn-rect" style="border-color:#ff4444;" ontouchstart="setKey('fire', true)" ontouchend="setKey('fire', false)" ontouchcancel="setKey('fire', false)">FIRE</div>
            <div class="mob-btn mob-btn-rect" style="border-color:#00d2ff;" ontouchstart="setKey('boost', true)" ontouchend="setKey('boost', false)" ontouchcancel="setKey('boost', false)">BOOST</div>
        </div>
    </div>
  </div>

  <!-- Screens -->
  <div id="start-screen" class="screen">
    <div class="menu-box">
      <h1 style="color:white; font-size:40px; margin-bottom:10px;">SKY PILOT</h1>
      <p style="color:#00d2ff; margin-bottom:30px;">Ultimate Level</p>
      <button class="action-btn" onclick="startSinglePlayer()">START GAME</button>
      <button class="action-btn secondary-btn" onclick="window.location.href='index.html'">BACK</button>
    </div>
  </div>

  <div id="pause-screen" class="screen hidden">
    <div class="menu-box">
      <h1 style="color:white;">PAUSED</h1>
      <button class="action-btn" onclick="togglePause()">RESUME</button>
      <button class="action-btn secondary-btn" onclick="location.reload()">RESTART</button>
    </div>
  </div>

  <div id="end-screen" class="screen hidden">
    <div class="menu-box">
      <h1 id="end-title" class="win-text">VICTORY</h1>
      <p id="end-msg" style="color:white; font-size:18px;">Mission Accomplished.</p>
      <button class="action-btn" onclick="location.reload()">PLAY AGAIN</button>
    </div>
  </div>

<script>
  // ✅ FIX: Rings count set to 8
  const Cfg = window.SKY_CONFIG || {
      RINGS_PER_LAP: 8, 
      TOTAL_RINGS_WIN: 8, 
      NORMAL_SPEED: 5, BOOST_SPEED: 10,
      TURN_SPEED: 0.03, LIFT_SPEED: 5, FIRE_RATE: 120, COLLISION_DAMAGE: 8,
      BOOST_DRAIN: 0.5, BOOST_REFILL: 0.1, 
      BULLET_SPEED_PLAYER: 25, BULLET_SPEED_ENEMY: 40,
      TERRAIN_COLORS: { SAND: 0xeebb88, GRASS: 0x55aa55, ROCK: 0x666666, SNOW: 0xffffff, WATER: 0x004488 }
  };
  
  const MAX_BULLETS = 80;
  const BULLET_GEO_P = new THREE.SphereGeometry(2, 8, 8);
  const BULLET_MAT_P = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
  const BULLET_GEO_E = new THREE.SphereGeometry(4, 8, 8);
  const BULLET_MAT_E = new THREE.MeshBasicMaterial({ color: 0xff0000 });

  let scene, camera, renderer, planeRig, planeMesh, guideArrow;
  let terrainMesh, oceanMesh, enemies = [], repairKits = [], rings = [], ringWaypoints = [];
  let currentRingObj = null, bullets = [], isPlaying = false, isPaused = false;
  let boostLevel = 100, health = 100, lastFireTime = 0, lastCrashTime = 0, playerLastRingIndex = -1;
  let miniTick = 0, aiTick = 0;

  let playerPrevPos = new THREE.Vector3(), playerVelocity = new THREE.Vector3();
  let playerStats = { name: "PLAYER", rings: 0, progress: 0 };
  let enemyStats = [{ name: "ACE", rings: 0, obj: null }, { name: "VIPER", rings: 0, obj: null }, { name: "GHOST", rings: 0, obj: null }, { name: "HAWK", rings: 0, obj: null }];
  let enemiesAliveCount = 4, visualRoll = 0, visualPitch = 0, lastFrameTime = performance.now(), frameCount = 0;
  
  const activeKeys = {};
  const fpsElem = document.getElementById('fps-counter');
  const minimapCtx = document.getElementById('minimap-canvas').getContext('2d');

  // Input Handling
  function getBindings() {
      if (window.GameManager && window.GameManager.data && window.GameManager.data.bindings) return window.GameManager.data.bindings;
      return { up:'w', down:'s', left:'a', right:'d', boost:' ', fire:'shift' };
  }
  function setKey(action, state) { 
      const binds = getBindings();
      if(action === "boost") { activeKeys[binds.boost] = state; activeKeys["Space"] = state; return; }
      if(action === "fire") { activeKeys[binds.fire] = state; activeKeys["shift"] = state; activeKeys["Shift"] = state; return; }
      activeKeys[binds[action]] = state;
  }
  window.addEventListener('keydown', (e) => {
      if(e.key === "Escape") { togglePause(); return; }
      const binds = getBindings(); const k = e.key.toLowerCase();
      if(k === binds.up || k === 'arrowup') activeKeys[binds.up] = true;
      if(k === binds.down || k === 'arrowdown') activeKeys[binds.down] = true;
      if(k === binds.left || k === 'arrowleft') activeKeys[binds.left] = true;
      if(k === binds.right || k === 'arrowright') activeKeys[binds.right] = true;
      if(k === binds.boost || (binds.boost === ' ' && e.code === 'Space')) activeKeys[binds.boost] = true;
      if(k === binds.fire || (binds.fire === 'shift' && (e.code === 'ShiftLeft' || e.code === 'ShiftRight'))) activeKeys[binds.fire] = true;
  });
  window.addEventListener('keyup', (e) => {
      const binds = getBindings(); const k = e.key.toLowerCase();
      if(k === binds.up || k === 'arrowup') activeKeys[binds.up] = false;
      if(k === binds.down || k === 'arrowdown') activeKeys[binds.down] = false;
      if(k === binds.left || k === 'arrowleft') activeKeys[binds.left] = false;
      if(k === binds.right || k === 'arrowright') activeKeys[binds.right] = false;
      if(k === binds.boost || (binds.boost === ' ' && e.code === 'Space')) activeKeys[binds.boost] = false;
      if(k === binds.fire || (binds.fire === 'shift' && (e.code === 'ShiftLeft' || e.code === 'ShiftRight'))) activeKeys[binds.fire] = false;
  });
  function isActionActive(id) { 
      const binds = getBindings();
      if(id === 'boost') return activeKeys[binds.boost] || activeKeys[" "] || activeKeys["Space"];
      if(id === 'fire') return activeKeys[binds.fire] || activeKeys["shift"] || activeKeys["Shift"];
      return activeKeys[binds[id]] || activeKeys['arrow'+id]; 
  }

  // Logic Functions
  function updateLeaderboard() {
      const list = document.getElementById('leaderboard-list'); if(!list) return; list.innerHTML = "";
      let racers = [playerStats, ...enemyStats].filter(r => r.name === "PLAYER" || (r.obj && r.obj.userData.alive));
      racers = racers.map(r => { if(r.name !== "PLAYER" && r.obj) r.rings = r.obj.userData.progress; return r; });
      racers.sort((a, b) => b.rings - a.rings);
      racers.forEach((r, i) => {
          const row = document.createElement("div"); row.className = "lb-row";
          if(r.name === "PLAYER") row.classList.add("lb-player"); if(i === 0) row.classList.add("lb-rank-1");
          row.innerHTML = `<span>${i+1}. ${r.name}</span><span>${r.rings}/${Cfg.TOTAL_RINGS_WIN}</span>`;
          list.appendChild(row);
      });
  }
  function togglePause() { if(!isPlaying) return; isPaused = !isPaused; document.getElementById('pause-screen').classList.toggle('hidden', !isPaused); if(!isPaused) requestAnimationFrame(animate); }
  function ringCollected(name) {
      const sfx = (typeof GameManager !== 'undefined' && GameManager.data) ? GameManager.data.sfx : true;
      if(typeof SFXManager !== 'undefined') SFXManager.playRing(sfx); 
      if(name === "PLAYER") {
          playerStats.rings++; playerStats.progress++; updateRingVisuals();
          if(playerStats.rings >= Cfg.TOTAL_RINGS_WIN) endGame(true, "RACE CHAMPION!");
      } else {
          const e = enemyStats.find(s => s.name === name);
          if(e && e.obj) { if(e.obj.userData.progress >= Cfg.TOTAL_RINGS_WIN) endGame(false, name + " WON THE RACE!"); }
      }
      updateLeaderboard();
  }
  function disposeHierarchy(obj) {
      if(!obj) return; if(obj.children) [...obj.children].forEach(disposeHierarchy); if(obj.geometry) obj.geometry.dispose();
      if(obj.material) { if(Array.isArray(obj.material)) obj.material.forEach(m => { if(m.map) m.map.dispose(); m.dispose(); }); else { if(obj.material.map) obj.material.map.dispose(); obj.material.dispose(); } }
  }
  let touchLocked = false;
  function preventTouch(e) { e.preventDefault(); }
  function lockTouchScroll() { if(touchLocked) return; touchLocked = true; document.body.addEventListener("touchmove", preventTouch, { passive: false }); }
  function unlockTouchScroll() { if(!touchLocked) return; touchLocked = false; document.body.removeEventListener("touchmove", preventTouch); }

  // Global Start Function
  window.startSinglePlayer = function() { initGame(); }

  function initGame() {
    lockTouchScroll();
    if(typeof SFXManager !== 'undefined') SFXManager.init(); if(typeof MusicManager !== 'undefined') MusicManager.init();
    document.getElementById('start-screen').classList.add('hidden');
    const container = document.getElementById('game-container');
    
    if(scene) { 
        rings.forEach(r => { scene.remove(r); disposeHierarchy(r); }); 
        bullets.forEach(b => { if(b.mesh.parent) b.mesh.parent.remove(b.mesh); });
        bullets.length = 0; repairKits.forEach(k => { scene.remove(k); disposeHierarchy(k); }); 
        enemies.forEach(e => { scene.remove(e); disposeHierarchy(e); });
        if(terrainMesh) { scene.remove(terrainMesh); disposeHierarchy(terrainMesh); }
        if(oceanMesh) { scene.remove(oceanMesh); disposeHierarchy(oceanMesh); }
    }
    if(renderer) { renderer.dispose(); if(renderer.forceContextLoss) renderer.forceContextLoss(); renderer.domElement.parentNode.removeChild(renderer.domElement); }
    
    rings = []; repairKits = []; enemies = []; bullets = []; ringWaypoints = [];
    scene = new THREE.Scene(); scene.background = new THREE.Color(0x87CEEB); 
    scene.fog = new THREE.Fog(0x87CEEB, 2000, 15000); // ✅ Less fog for better view
    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 10000); 
    renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" }); 
    renderer.setSize(window.innerWidth, window.innerHeight); renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1)); 
    container.innerHTML = ''; container.appendChild(renderer.domElement);
    scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 0.6));
    const dl = new THREE.DirectionalLight(0xffffff, 0.8); dl.position.set(100, 200, 50); scene.add(dl);
    
    // ✅ Integration: MapManager calls
    terrainMesh = MapManager.generateTerrain(Cfg); scene.add(terrainMesh);
    oceanMesh = MapManager.generateOcean(Cfg); scene.add(oceanMesh);
    const ringData = MapManager.generateRings(Cfg.RINGS_PER_LAP); rings = ringData.rings; ringWaypoints = ringData.waypoints;
    rings.forEach(r => scene.add(r));

    playerStats = { name: "PLAYER", rings: 0, progress: 0 }; playerLastRingIndex = -1; health = 100; boostLevel = 100;
    createPlaneSystem(); createGuideArrow(); createRepairKits(); createEnemies();
    updateRingVisuals(); updateLeaderboard();
    playerPrevPos.copy(planeRig.position);
    isPlaying = true; isPaused = false; animate();
  }

  function createPlaneMesh(color) {
      const g = new THREE.Group(); const mat = new THREE.MeshStandardMaterial({ color, roughness: 0.4 });
      const body = new THREE.Mesh(new THREE.CylinderGeometry(2, 4, 30, 8), mat); body.rotateX(-Math.PI/2);
      const nose = new THREE.Mesh(new THREE.ConeGeometry(2, 10, 8), mat); nose.rotateX(-Math.PI/2); nose.position.z = -20;
      const wings = new THREE.Mesh(new THREE.BoxGeometry(20, 0.5, 10), mat); wings.position.set(0, 0, 5);
      g.add(body, nose, wings); return g;
  }
  function createPlaneSystem() { 
      planeRig = new THREE.Group(); planeRig.position.set(0, 400, 800); scene.add(planeRig); 
      planeMesh = createPlaneMesh(0x555555); planeRig.add(planeMesh); 
      const glow = new THREE.Mesh(new THREE.ConeGeometry(3, 10, 8), new THREE.MeshBasicMaterial({ color: 0x00d2ff, transparent: true, opacity: 0 }));
      glow.rotateX(Math.PI/2); glow.position.z = 20; glow.name = "EngineGlow"; planeMesh.add(glow); 
  }
  function createEnemies() {
      for(let i=0; i<4; i++) { 
          const e = new THREE.Group(); e.add(createPlaneMesh(0xaa0000)); e.position.set((i - 1.5) * 200, 400, 400); e.name = enemyStats[i].name;
          e.userData = { alive: true, health: 300, speed: Cfg.NORMAL_SPEED, progress: 0, lastShot: 0, ai: { aggression: 0.5, aim: 0.7, dodge: 0.6 }, state: "RACE", stateTimer: 0, dodgeTimer: 0, lastRingIndex: -1 }; 
          scene.add(e); enemies.push(e); enemyStats[i].obj = e; 
      }
  }
  function createGuideArrow() { guideArrow = new THREE.Group(); guideArrow.add(new THREE.Mesh(new THREE.ConeGeometry(4, 10, 8), new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent:true, opacity:0.8 }))); guideArrow.children[0].rotateX(Math.PI/2); scene.add(guideArrow); }
  function updateRingVisuals() { const curr = playerStats.progress % Cfg.RINGS_PER_LAP; rings.forEach((r, i) => { if(i === curr) { r.material.emissive.setHex(0xffaa00); r.visible = true; currentRingObj = r; } else r.visible = false; }); }
  function createRepairKits() { [{x:1000,z:-3000},{x:-2000,z:-6000}].forEach(l => { const kit = new THREE.Mesh(new THREE.BoxGeometry(40,40,40), new THREE.MeshPhongMaterial({color:0x00ff00})); kit.position.set(l.x, MapManager.getTerrainHeight(l.x,l.z)+200, l.z); kit.userData={active:true}; scene.add(kit); repairKits.push(kit); }); }

  function spawnBullet() {
      const sfx = (typeof GameManager !== 'undefined' && GameManager.data) ? GameManager.data.sfx : true;
      if(typeof SFXManager !== 'undefined') SFXManager.playGun(sfx); 
      const bullet = new THREE.Mesh(BULLET_GEO_P, BULLET_MAT_P); bullet.position.copy(planeRig.position);
      const v = new THREE.Vector3(0,0,-1).applyQuaternion(planeRig.quaternion).multiplyScalar(Cfg.BULLET_SPEED_PLAYER);
      bullets.push({ mesh: bullet, velocity: v, target: null, life: 150 }); scene.add(bullet);
  }
  function spawnEnemyBullet(enemy, targetPos) {
      const bullet = new THREE.Mesh(BULLET_GEO_E, BULLET_MAT_E); bullet.position.copy(enemy.position);
      const v = new THREE.Vector3().subVectors(targetPos, enemy.position).normalize().multiplyScalar(Cfg.BULLET_SPEED_ENEMY);
      bullets.push({ mesh: bullet, velocity: v, life: 200, isEnemy: true, owner: enemy }); scene.add(bullet);
  }

  function drawMinimap() { if(!minimapCtx || !planeRig) return; minimapCtx.clearRect(0,0,140,140); const cx=70, cy=70, scale=60/5000; minimapCtx.save(); minimapCtx.translate(cx,cy); minimapCtx.rotate(-planeRig.rotation.y+Math.PI); minimapCtx.beginPath(); minimapCtx.moveTo(0,-6); minimapCtx.lineTo(-4,4); minimapCtx.lineTo(4,4); minimapCtx.fillStyle="#00ff00"; minimapCtx.fill(); minimapCtx.restore(); function dot(o,c,s) { if(!o || !o.visible) return; const dx=(o.position.x-planeRig.position.x)*scale, dz=(o.position.z-planeRig.position.z)*scale, d=Math.sqrt(dx*dx+dz*dz); let px=dx, py=dz; if(d>65) { px*=65/d; py*=65/d; } minimapCtx.beginPath(); minimapCtx.arc(cx+px, cy+py, s, 0, Math.PI*2); minimapCtx.fillStyle=c; minimapCtx.fill(); } if(currentRingObj) dot(currentRingObj, "#ffd700", 4); enemies.forEach(e => { if(e.userData.alive) dot(e, "#ff0000", 3); }); }

  function animate() {
      if(!isPlaying || isPaused) return;
      frameCount++; const t = performance.now(); if(t-lastFrameTime>=1000) { if(fpsElem) fpsElem.innerText="FPS: "+frameCount; frameCount=0; lastFrameTime=t; }
      const now = Date.now(); playerVelocity.subVectors(planeRig.position, playerPrevPos).clampLength(0, 50); playerPrevPos.copy(planeRig.position);
      
      if(isActionActive('fire') && now-lastFireTime > Cfg.FIRE_RATE && bullets.length < MAX_BULLETS) { spawnBullet(); lastFireTime = now; }

      // ✅ AI Logic with clipping fix
      aiTick++; const runAI = (aiTick % 2 === 0);
      enemies.forEach((e, idx) => {
          if(!e.userData.alive) return;
          const wp = ringWaypoints[e.userData.progress % Cfg.RINGS_PER_LAP]; if(!wp) return;
          const target = new THREE.Vector3(wp.x, wp.y, wp.z);
          const dummy = new THREE.Object3D(); dummy.position.copy(e.position); dummy.lookAt(target); dummy.rotateY(Math.PI);
          e.quaternion.slerp(dummy.quaternion, 0.03); e.translateZ(-e.userData.speed);
          
          // ✅ Fix: Clipping height check strengthened (h + 120)
          const h = MapManager.getTerrainHeight(e.position.x, e.position.z);
          if(e.position.y < h + 120) { e.position.y = h + 120; e.rotation.x -= 0.05; }
          
          if(e.position.distanceTo(target) < 200 && e.userData.lastRingIndex !== (e.userData.progress % Cfg.RINGS_PER_LAP)) {
              e.userData.lastRingIndex = e.userData.progress % Cfg.RINGS_PER_LAP; e.userData.progress++; ringCollected(e.name);
          }
          if(runAI && Math.random() < 0.01) spawnEnemyBullet(e, planeRig.position);
      });

      // Bullets Processing
      for(let i=bullets.length-1; i>=0; i--) {
          const b = bullets[i]; b.mesh.position.add(b.velocity); b.life--;
          const gh = MapManager.getTerrainHeight(b.mesh.position.x, b.mesh.position.z);
          if(b.mesh.position.y < gh + 10 || b.life <= 0) { if(b.mesh.parent) b.mesh.parent.remove(b.mesh); bullets.splice(i, 1); continue; }
          if(b.isEnemy) { if(b.mesh.position.distanceTo(planeRig.position) < 80) { health -= 10; if(b.mesh.parent) b.mesh.parent.remove(b.mesh); bullets.splice(i, 1); continue; } }
          else { enemies.forEach(e => { if(e.userData.alive && b.mesh.position.distanceTo(e.position) < 100) { e.userData.health -= 50; if(e.userData.health<=0){e.userData.alive=false; e.visible=false;} if(b.mesh.parent) b.mesh.parent.remove(b.mesh); bullets.splice(i, 1); } }); }
      }

      // Player Movement
      let spd = isActionActive('boost') && boostLevel > 0 ? Cfg.BOOST_SPEED : Cfg.NORMAL_SPEED;
      if(isActionActive('boost') && boostLevel > 0) { boostLevel -= Cfg.BOOST_DRAIN; planeMesh.getObjectByName("EngineGlow").material.opacity = 0.8; } 
      else { boostLevel = Math.min(100, boostLevel + Cfg.BOOST_REFILL); planeMesh.getObjectByName("EngineGlow").material.opacity = 0; }
      document.getElementById('boost-fill').style.width = boostLevel + '%'; planeRig.translateZ(-spd);
      
      if(isActionActive('left')) { planeRig.rotation.y += Cfg.TURN_SPEED; visualRoll = THREE.MathUtils.lerp(visualRoll, 0.8, 0.1); }
      else if(isActionActive('right')) { planeRig.rotation.y -= Cfg.TURN_SPEED; visualRoll = THREE.MathUtils.lerp(visualRoll, -0.8, 0.1); }
      else visualRoll = THREE.MathUtils.lerp(visualRoll, 0, 0.1);
      
      if(isActionActive('up')) { planeRig.position.y += Cfg.LIFT_SPEED; visualPitch = THREE.MathUtils.lerp(visualPitch, -0.4, 0.1); }
      else if(isActionActive('down')) { planeRig.position.y -= Cfg.LIFT_SPEED; visualPitch = THREE.MathUtils.lerp(visualPitch, 0.4, 0.1); }
      else visualPitch = THREE.MathUtils.lerp(visualPitch, 0, 0.1);
      
      const gh = MapManager.getTerrainHeight(planeRig.position.x, planeRig.position.z);
      if(planeRig.position.y < gh + 20) { planeRig.position.y = gh + 20; if(now - lastCrashTime > 500) { health -= Cfg.COLLISION_DAMAGE; lastCrashTime = now; } }
      if(health <= 0) endGame(false, "SYSTEM FAILURE");

      document.getElementById('health-fill').style.width = health + '%';
      planeMesh.rotation.z = visualRoll; planeMesh.rotation.x = visualPitch;
      const ct = new THREE.Vector3(0, 100, 300).applyMatrix4(planeRig.matrixWorld); camera.position.lerp(ct, 0.1); camera.lookAt(planeRig.position);
      
      if(currentRingObj) { guideArrow.visible = true; guideArrow.position.copy(planeRig.position).y += 60; guideArrow.lookAt(currentRingObj.position); if(planeRig.position.distanceTo(currentRingObj.position) < 120 && playerLastRingIndex !== playerStats.progress) { playerLastRingIndex = playerStats.progress; ringCollected("PLAYER"); } }
      
      miniTick++; if(miniTick >= 6) { drawMinimap(); miniTick = 0; }
      renderer.render(scene, camera); requestAnimationFrame(animate);
  }

  function endGame(win, reason) { 
      isPlaying = false; unlockTouchScroll(); if(typeof MusicManager !== 'undefined') MusicManager.stop();
      if(win) { if(typeof MusicManager !== 'undefined') MusicManager.playWin(); } else { if(typeof MusicManager !== 'undefined') MusicManager.playLose(); }
      const s = document.getElementById('end-screen'); s.classList.remove('hidden');
      document.getElementById('end-title').innerText = win ? "VICTORY" : "DEFEAT";
      document.getElementById('end-title').className = win ? "win-text" : "lose-text";
      document.getElementById('end-msg').innerText = reason;
  }
  window.addEventListener('resize', () => { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
</script>
</body>
</html>
